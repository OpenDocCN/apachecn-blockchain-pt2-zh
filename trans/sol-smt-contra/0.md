可靠智能合约

Solidity Smart Contracts

在以太坊区块链中构建 DApps

介绍

Introduction

我要感谢并祝贺你得到了这本书，《可靠的智能合约:在以太坊街区建立 Dapps》。

这本书包含了如何成为一个可靠的，聪明的合约创建和以太坊区块链发展的大师证明的步骤和策略。

大家好，欢迎来到我们关于可靠智能合约的课程。

为了能够首先开始制定自己的智能合约，我们需要后退一步，了解以太坊区块链的一些最重要的方面。

我们将从一小段历史开始，了解以太坊区块链到底是什么，以及它在这场快速发展的全球技术变革中扮演的角色。

为了理解整个系统，以及如何以尽可能少的功能成本使我们的智能合约成为可能的最佳方式，我们需要了解以太坊区块链的机制。

我将向你展示如何制作你的第一个钱包，如何管理它，然后我们将继续学习一点密码学、区块分析和汽油价格。

起初事情可能看起来有点令人不知所措，但是一旦你掌握了它的窍门，当我们进入编码部分时，你会感激这些知识。

每个制定智能合约的开发人员都需要访问我们将在其上部署合约的测试网络。为了做到这一点，我们必须在我们的主网络帐户旁边创建一个测试网络帐户，最重要的是，我们必须有一些测试网络来使用。

我将向你展示几个简单的方法，让你尽可能多地获得你可能需要的以太，在你的“称之为旅程”中，创建一个可靠的智能合约。

我们来看看一些大宗交易和图表解释。一些免费使用但非常有用的网站，帮助您跟踪区块链网络和更多。

再次感谢你购买这本书，我希望你喜欢它！

Thanks again for buying this book, I hope you enjoy it!

版权所有 2019 uni bul 出版社有限公司-保留所有权利。

 Copyright 2019 by Unibul Press Ltd. - All rights reserved.

本文件旨在就所涵盖的主题和问题提供准确可靠的信息。该出版物的销售理念是，出版商不需要提供会计、官方许可或其他合格的服务。如果建议是必要的，法律的或专业的，应该命令一个在专业上有经验的人。

This document is geared towards providing exact and reliable information in regards to the topic and issue covered. The publication is sold with the idea that the publisher is not required to render accounting, officially permitted, or otherwise, qualified services. If advice is necessary, legal or professional, a practiced individual in the profession should be ordered.

——摘自美国律师协会的一个委员会和出版商协会的一个委员会平等接受和批准的一项原则宣言。

- From a Declaration of Principles which was accepted and approved equally by a Committee of the American Bar Association and a Committee of Publishers and Associations.

以电子方式或印刷格式复制、复制或传输本文档的任何部分都是不合法的。严禁录制本出版物，除非获得出版商的书面许可，否则不允许对本文档进行任何存储。保留所有权利。

此处提供的信息被声明为真实和一致的，因为任何责任，就疏忽或其他而言，由任何使用或滥用其中包含的任何政策、流程或指示而言，是收件人读者的单独和完全的责任。在任何情况下，出版商都不会因本文信息直接或间接导致的任何赔偿、损害或金钱损失承担任何法律责任或责任。

各自的作者拥有不属于出版商的所有版权。

此处的信息仅供参考，因此具有普遍性。信息的呈现没有合约或任何类型的担保保证。

使用的商标未经任何同意，商标的发布未经商标所有人的许可或支持。本书中的所有商标和品牌仅用于澄清目的，归所有者所有，与本文档无关。

以太坊区块链是什么？

在第一章中，我们将谈论区块链以太坊以及它到底是什么。

在过去的几年里，没有多少人没有听说过比特币、以太坊或区块链技术。

所有媒体产生的嗡嗡声已经导致该行业的巨大飞跃，最好的还在后头。

我会尽量让事情变得简单，我不会进入那些可能会让你困惑的非必要的东西。

根据定义，以太坊是一种开源的公共服务，使用区块链技术来帮助智能合约和加密货币交易，没有第三方的参与。

以太坊提供了两种类型的帐户:外部拥有的-这些是我们拥有自己的私钥的公共帐户。第二个是合约账户。那些是以太坊开发者部署各种智能合约的账号。

以太坊区块链仍然是最大的智能合约生态系统，是众多 alt 币和应用的家园。

凭借其快速增长的社区和潜力，JP 摩根、英特尔和微软等许多大公司正在涉足智能合约业务和分散服务。

现在我们来谈谈区块链以太坊背后的货币，也就是所谓的以太。

这是我们将在 Solidity 智能合约开发中使用的货币，也是赞助大多数 ico 的主要货币。

根据大多数预测，预计在不久的将来，比特币的市值甚至会超过比特币。

能够制定自己的智能合约不仅能让你在这个快速发展的行业开始职业生涯，还能让你制定自己的 DApp。

一些最著名的是加密小猫和 IDEX。

以太坊的创始人 Vitalik Buterin 的总体想法是，区块链技术可以做的不仅仅是支付交易。因此，在他 19 岁的时候，他发布了一份白皮书，用一种通用脚本语言描述了最终成为以太坊的东西。

与母币比特币的关键区别在于平台 m 的交易能力不仅仅是加密货币。

你们中的一些人可能听说过像加密猫，分散聊天和所有其他种类的应用程序这样的项目。

事实是…区块链技术仍在发展，但每个与之有过互动的人都认为它是有潜力的。由于区块链共识算法，每笔交易背后的安全性都是不可逾越的。

在下一个视频中，我将向您展示什么是数据块，它们是如何生成的，以及通过区块链发送的每个操作背后的机制。

最后，我们将看看区块链的现状，它所面临的问题和可能的解决方案。

[在
codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

在 Debth 进行更多

在这一章中，我们将谈论一些在区块链中技术上但必要的事情。别害怕…我会尽可能把事情简单化。

我要打开一个名为 [etherscan . io](https://etherscan.io/) 的网页

![](Image00000.jpg)

在这个网站上，我们几乎可以看到我们可能需要的所有相关统计数据，以便跟踪区块链运动。

首先让我们来谈谈信息是如何在区块链上传输和存储的。

如果你曾经拥有过任何一种加密货币，你会知道你必须支付某种交易费才能把你的钱转给别人。这与我们银行转账时银行收取的费用不同，但这是网络本身的费用。

从这个角度来看…当您点击“sen d”时，您的事务将进入其他事务池，等待网络传输和验证。这种验证，至少在以太坊区块链，是由所谓的矿工进行的。

为了达成交易，我们必须告诉网络我们愿意支付多少油钱。金额越高，我们的事务进入下一个将被挖掘/验证的块的速度就越快。

我们会在下节课中讨论天然气，所以现在要记住，有某种交易费。

现在让我们看看以太扫描，看看我们能看到什么。

在左侧有一个列表，其中列出了所有最近生成的、已经过网络验证的块。每个块都包含许多事务或智能合约操作。

目前，大约每 14 秒就有一个新的区块，这意味着当你试图向某人发送货币时，你的交易将进入其中一个区块，这取决于网络流量和你设置的油钱数量。

当我们单击其中一个生成的块时，我们将看到它包含的所有信息。

首先，我们有高度，这就像块的序列号。

我们有一个时间戳来知道它被验证的确切时间。

我们可以看到进入该块的交易数量，如果有 y，还可以看到内部智能合约交易的数量。

我们现在将跳过散列，因为在这一点上没有必要进入它们。

之后我们就能知道是谁开采了这个区块。大多数时候，y 矿是由矿池开采的，基本上是矿工之间的合作，他们为开采的每个区块分配价格。

随着时间的推移，开采一个区块的难度呈指数增长。仅在过去的 10 个月里，难度就增加了两倍，这意味着矿商的利润减少了。

之后，我们得到了块的大小以及它以字节为单位保存的所有信息。

下面是人们为交易支付的用过的汽油。

每个被开采的区块都有一个固定的奖励，奖励由三个以太网组成，到达开采区块的矿工的地址，加上汽油钱和叔叔们(如果有的话)。

大叔们就是这样所谓的孤儿街区。这样想吧…一个矿工找到了正确的方块标题，第二个矿工在他之后瞬间找到了解决方案。第一名矿工继续在主区块链上采矿，而第二名矿工实际上是在一个平行的上采矿。当 14 秒后下一个块出现时，两个区块链同步。

比特币叔叔之间的区别在于，在这里，第二名矿工因在区块链分裂期间所做的大量工作而获得奖励。

现在，让我们点击交易，看看我们有什么:

![](Image00001.jpg)

在此窗口中，我们将获得该块中所有事务的信息。

我们可以看到每个事务的唯一散列。寄件人的地址，当然还有收件人。

您还可以看到已转移的值。

您可能会注意到，在某些情况下，该值为零。也就是说，交易是通过智能合约进行的。

最后，我们可以看到为每笔交易支付的交易费。

TxFees 的原理很简单。根据网络速度和流量，我们有 N 个事务可以进入下一个要挖掘的数据块。谁支付的费用最高，谁的交易传输就越快。

支付最低费用并不意味着你的交易不会被传输，但可能需要更多的时间，这取决于当前的流量。

以太坊网络的问题(不仅仅是)在于，至少目前它依赖于矿工来验证块。问题是采矿设备非常昂贵而且耗电。

这就是为什么在过去的几年中，以太坊项目背后的团队和社区正在采取措施从 POW(工作证明)转移到 POS(利益证明)验证机制。我们不会深入讨论它们，因为它们与我们的课程无关，但如果您感兴趣，社区中有大量相关资料。

第二个也可能是更大的问题是网络的扩展和 TPS(每秒交易量)的增加。幸运的是，随着社区的快速发展，我们可能会在不久的将来看到一些大的改进。

在下一个视频中，我们将制作我们的第一个以太坊钱包，我们将浏览所有必要的安全说明，以确保我们的财务安全。

[在
codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

创建以太钱包

在这个视频中，我们将制作我们的第一个以太坊钱包，我将向你解释所有的安全风险和选择，希望你能避免被黑客攻击和财产损失。

所以首先我们需要去 https://www.myetherwallet.com/ [](https://www.myetherwallet.com/) 。

![](Image00002.jpg)

当您打开网页时，您将看到一个弹出窗口，显示有关该网站的一些信息。个人建议你看一下。这很重要。

还要确保每次打开网站时，你都能在名字栏的左侧看到“MyEtherWallet INC [US]”。如果这是失踪，你最有可能是在一个钓鱼网站，想窃取您的信息。

完成后，弹出窗口消失，我们在主页上。

这里非常简单…你可以看到，为了创建我们的钱包，我们需要做的唯一一件事就是输入密码。

在你输入你想输入的密码之前，确保你不会在其他网站上使用它，这要复杂得多，最重要的是你要把它写在一张纸上。

现在，我将键入我将在本课程中使用的密码，然后单击。

在下一个窗口，我们被要求保存我们的密钥库文件。

Now I’ m going to type my password that I’ ll use in this course and click.

![](Image00003.jpg)

为了使用你的以太坊钱包，你有很多种方法可以找到并打开钱包。

其中之一是密钥库文件。该文件包含有关您个人私钥的加密信息，您可以用它来解锁您的钱包。

下载你的文件，保存在闪存驱动器上，如果可能的话，在另一个驱动器上备份。不要把文件保存在你的个人电脑上，也不要把你的密码写在笔记或任何你电脑上的文件上。

下载文件后，单击继续。

现在网站给我们提供了个人私钥。这个私钥是唯一的，在交易过程中没有人能看到它，这是你所有数字资产的关键。

您可以将它复制/粘贴到您用于密钥库文件的闪存驱动器内的文件夹中，并将其写在一张纸上。

从这里开始，网站会将我们带到我们每次想要解锁和使用钱包时将要看到的页面。

如您所见，有许多选项，但我将讨论最常见的选项。

![](Image00004.jpg)

首先，我们有超面具/薄雾。MetaMask 是一个浏览器扩展，我们会在课程中经常用到。因此，我们将有一个单独的视频。

[账本](https://www.ledger.com/) 是一个硬件钱包。它是一种类似闪存盘的设备，带有保护您资产的软件。根据你所在的国家不同，它的费用大约在 70-100 美元之间，但这是迄今为止保护你的资金最安全的方法。

[Trezor](https://trezor.io/) 是同样的硬件保护装置但是有点大 r … 像外置硬盘。

我们将跳过接下来的两个步骤，在这之后，您可以看到我们可以选择使用密钥库/ JSON 文件来解锁我们的钱包。

当我们单击该选项时，您会看到建议我们不要使用该选项…为什么这么问？为了使用它，我们必须将文件上传回网站的服务器，在上传过程中，文件可能会被劫持，最终我们可能会被黑客攻击。

保存文件是一件好事，但除非你完全忘记并丢失了密码，否则尽量不要使用它。

下一个选项是助记短语。把它想象成一个容易记住的牢不可破的密码。在不同的钱包/网站中，长度是不同的，但它是在 14 到 21 个单词之间，按照给定的顺序。

同样，该网站告诉我们，这不是一个值得推荐的方式来访问我们的钱包。老实说，除非你有一个硬件钱包，否则当你这样做时，它永远不会安全，所以总是试图采取必要的预防措施。

比如……永远不要从公共 Wi-Fi 访问你的钱包，总是检查网站域名，以防你意外进入钓鱼网站之类的东西。

最后但并非最不重要的一点是，我们的私钥选项也有同样的建议。如果您单击了元掩码选项，您可能会看到这是访问您的资产的唯一推荐选项。这就是为什么一旦我们将扩展连接到我们的钱包，我们就不需要去网站或键入任何类型的信息，这使得它更安全。

我将带着 JSON 文件进入钱包，因为它仅用于教学目的。如您所见，在我上传文件后，我还被要求输入钱包密码。

不，当我们解锁后，我们可以访问里面的所有信息和资产。

在第一行，我们有我们的地址。这是每个人都会寄给你以太币的地址。

我们可以重新下载 JSON 文件并查看我们的私钥，以防丢失。

我们有印刷纸质钱包的选择，老实说我从来没有这样做过，但这是为了你的安全的另一个选择。

![](Image00005.jpg)

在右侧，您可以看到您当前的 ETH 余额。ETH 是我们钱包里的主要货币。在它下面，我们有象征性的余额。

这是所有基于以太坊的代币/货币将被显示的地方。如果您想查看所有可用的令牌，请按“显示所有令牌”,这将加载一个包含所有令牌的列表。

为了获取幕帘类型的令牌，您需要在列表中找到它，然后单击加载。这样，令牌信息将被上传到您的钱包，您将能够收到它。

![](Image00006.jpg)

In order to acquire a curtain type of token you need to find it in the list and click load. That way the token info will be uploaded to your wallet and you will be able to receive it.

最后但同样重要的是，如果你计划投资 ico，你必须自己添加令牌信息。

您可以通过按下自定义令牌按钮来完成此操作，在该按钮中，您必须粘贴 ICO 提供给您的令牌地址、符号和小数。

好了，这就是我们第一个钱包的制作和我们需要知道的最重要的事情。

[在
codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

不同种类的钱包

因此，在这段视频中，我将向你展示你可以使用的不同种类的钱包。

对于熟悉它们的人，可以跳过这一课，直接进入下一课。

好的…在之前的视频中，我们已经使用 MyEtherWallet 网站制作了我们的第一个以太坊钱包。这种钱包被称为在线钱包。如果你是一个安全狂或者你有一大笔投资，它们不应该是你的首选。

让我们来谈谈软件钱包。一种常见的软件钱包是 coi n 的官方区块链……例如以太坊。但是为了让你的钱包正常工作，你必须将你的区块链拷贝与官方拷贝同步，这可能会占用你大量的硬盘和时间。

我个人用过像 Exodus: [https://www.exodus.io/](https://www.exodus.io/) 这样的软件钱包

Le t’ s talk about software wallets. One of the common software wallets is the official blockchain of the coi n … for instance the Ethereum. But in order for your wallet to be functional yo u’ ll have to synchronize your copy of the blockchain with the official one which depending on the coin might take a lot of your hard drive and time.

这是一个令人惊叹的应用程序，具有非常简洁的用户界面，使管理您的资产变得简单和安全，就像它可以放在软件钱包中一样。当你第一次下载并安装它的时候，如果我没记错的话，你会得到一个 14 个单词的助记短语。

这 14 个字是你的备份钥匙，以防你的电脑坏了，软件被删除了，或者你失去了对软件的控制。当然，你会被要求输入一个密码，我再次强烈建议你输入一个尽可能长且唯一的密码。

之后，我们有了所谓的硬件钱包。我已经在之前的视频中告诉过你关于纳米账本和 Trezor 设备…所以现在让我们来看看它们。

她的 e 纳米账本网站:【https://www.ledger.com/】

它看起来像一个闪存盘，但不要被愚弄，它背后的安全性是惊人的。同样，我们有助于记忆的短语、密码和高标准的安全性。如果你丢失了你的账本，你可以订购一个新的，把丢失账本里的货币和助记短语放在一起。与软件钱包相比，硬件钱包的优势在于它们几乎不可破解。

他的 Trezor 钱包的网站:【https://trezor.io/】

正如我之前告诉你的，这几乎是相同的设备，只是外观不同。

H e’ s the website for the Trezor wallet: [https://trezor.io/](https://trezor.io/)

最后但同样重要的是，我们有兑换钱包。

在过去的几年里，许多交易所遭到黑客攻击，许多人失去了大部分或全部资金，这导致所有加密货币的价格大幅下跌。

但即便如此，许多人仍在使用外汇账户来存储他们的资产。不要误解我……如果有一天你决定进行日内交易，这很好，但是要记住不要持有大量的货币，不管这个交易所有多大或者有多可信。

为了举例，我给你看一个最大的交易所: [https://www.binance.com/](https://www.binance.com/)

![](Image00007.jpg)

安全措施每天都在变得越来越好，因此人们可以放心地将他们的资产交给交易所。例如，在你建立一个账户后，你会注意到你有几层保护来进入你的账户。

之后，如果你试图提取资金，你必须通过发送到你手机上的代码或认证，电子邮件或你添加的任何选项来验证交易。

处理加密货币最重要的一点是，你必须承认，对于你的资产会发生什么，以及你相信它们会安全存放在哪里，你只有你自己会承担责任。

在下一个视频中，我们将讨论 Metamask，我将向您展示处理主网络和测试网络钱包之间的区别，之后我们将了解什么是 GAS。

下节课再见。

[在
codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

元掩码简介

在这个视频中，我将向你展示我们将用作钱包的主要应用程序。

![](Image00008.jpg)

正如我在前面的视频中所说的，当我们想要进入智能合约业务时，Metamask 变得至关重要。

所以让我们先说说元掩码实际上是什么…

该应用程序实际上是谷歌浏览器的扩展。它与 ERC-20 代币一起工作，这是区块链以太坊中最常见的代币，信不信由你，它是最安全的软件钱包之一。

让我们从安装 chrome 浏览器的扩展开始。

只要在谷歌商店搜索栏中键入名称，它应该会第一个弹出来。

当我们将元掩码添加到浏览器中后，就该设置它了。

首先，我们要做第一笔账。为了做到这一点，我们被要求输入密码并确认。

和所有其他类型的钱包一样，使用你在其他网站上不常使用的独特密码，并把它写在一张纸上。

现在我们有了一个所谓的“see d”或助记短语。这个短语是我们的备份密钥。

如果我的电脑损坏、丢失或被盗，我需要在另一台设备上重新安装 Metamask 这是解决问题的关键。

我强烈建议你不要把“see d”保存在你的个人电脑或任何电子设备上。把它写在一张纸上…至少 2-3 次，然后把复印件放在一个安全的地方。

没有。在我们完成种子元掩码的备份后，元掩码要求我们再次检查我们的种子，并将其输入系统。这样我们就能 100%确定我们写下的内容是正确的，并且是有效的。

那就是……我们的账户都已经建立好了。现在我们进入了更有趣的部分。

让我们先点击 Metamask 图标，看看我们有什么。

如你所见，我们的余额目前为零。

在扩展的顶部，我们可以看到这个小方框，它告诉我们当前连接到哪个网络…

和其他开发人员一样，我们需要一个安全的地方来测试和部署我们的工作，在这里是我们的智能合约。

不，让我们来获得一些免费的以太网，我们在测试网络中发送到我们的帐户。

我们首先要做的是去这个网站:[](https://faucet.rinkeby.io/)

![](Image00009.jpg)

这里我们给出了三个基本上与时间相关的选项，这样可以防止垃圾邮件服务。

让我们追求最高的数量…所以为了得到那些 18.5 乙醚，我们所要做的就是进入我们的元掩码，并在我们的测试网址上点击“复制到剪贴板 d”。

之后，我们只需将该地址粘贴到三个社交媒体中的任何一个，并将帖子的链接复制/粘贴回 Rinkeby 网站。

当你掌握它的窍门时，一切只需要 1-2 分钟或更少的时间。

…我们完成了。

我们有 18.5 个以太网要处理，同时我们学习用 Solidity 制作您的第一个智能合约。

你可能会问，如果我们要制定明智的合约，为什么我们还需要乙醚

正如我在之前的视频中所说，有一种叫做汽油的东西，当我们想要进行交易时，或者在我们的智能合约进行的每个操作中，我们都需要支付它。

因此，把天然气想象成以太网中进行交易或签订合约的内部定价。

正如我之前说过的，你愿意支付的汽油价格越高，你的交易进入下一个区块的速度就越快…

有了智能合约，事情变得有点棘手，因为我们要为每一行代码花费精力。

她的 e 是一个简单的表格，显示了每个动作的一些气体值:

![](Image00010.jpg)

如您所见，部署和运行我们的智能合约可能会变得非常昂贵，因此正确地执行它非常重要。

但是不要害怕数字 s…1 天然气/乙醚的实际价格是一个非常小的数目，它取决于当前的网络流量和验证交易的矿工人数。

如果我们回到 https://etherscan.io/chart/gasprice 的 [](https://etherscan.io/chart/gasprice) 我们在第一个视频中访问的网站，我们可以看到当前的天然气价格以及最低和最高价格。

现在你可能会问为什么上面说最小气体值是 1 微？

卫是乙醚的最小单位。

1 以太等于 10 亿微(10 ^ 18)

十亿分之一。一个有 18 个零

如果天然气价格下降很多，最小数量将计入我们的收入中

在我们开始关于智能合约的第一堂课之前，让我们先来恢复我们的元掩码帐户。

右键点击图标，将其从 chrome 中移除。

![](Image00011.jpg)

现在，我们已经删除了 i t …它应该播放损坏的 PC 场景或任何其他类型的“灾难”…

我们去商店重新安装吧。

好了，我们又安装了 Metamask

现在我们必须接受所有的条款和条件。

之后的第一个窗口是使用我们保存的种子词恢复以前的钱包。

按正确的顺序输入你的单词，然后设置一个密码。

我们可以使用种子来恢复帐户，但是每次新安装时，我们都必须设置新的密码。

就是这样。

好的…我想这就是我们需要知道的关于超能面具和气体的全部内容。

因此，下一步是开始学习稳健和智能合约。

下节课再见。

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 的
获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

坚实性介绍:合约、构造函数和函数

在这一讲中，我们将讨论合约、构造函数和函数。

好吧，让我们开始吧。

让我们先来看看什么是 solidity 源文件的结构。

这里我们可以看到一份合约样本。

![](Image00012.jpg)

在每个 solidity 文件的顶部都有一个所谓的 version pragma，它告诉我们合约支持的 solidity 的最低版本。

之后，我们有合约和它的名字。

在它里面，我们可以放置变量声明、映射、构造函数、函数、修饰符等等。

现在，让我们看一份合约样本。

![](Image00013.jpg)

在这里，我们有两个合约，称为自有令牌和令牌创建者。您可以在一个 solidity 文件中声明多个合约。

正如您所看到的，我们也可以像这个例子一样从其他合约中调用合约。

在这之后，我们有了变量声明 owner 和 name，它们用于存储合约所有者的地址和合约的名称。

就在它们下面，我们有一个构造函数。请记住，在构造函数之前的几个版本都像合约一样被声明为同名的函数。然而，现在我们使用关键字构造函数。

因此，构造函数是一个在合约被部署到网络时只运行一次的函数。

当我们部署这个合约时，我们可以用它来发送变量名。这个变量保存在状态变量 name 中，我们的 wallet 地址保存在状态变量 owner 中。

现在，我们可以使用这个引用来检查和限制非合约所有者使用的函数。

好，现在让我们看看函数的结构是什么。

![](Image00014.jpg)

如果你熟悉 JavaScript，函数看起来很像那里的那些。然而，我们有一些额外的修饰词。在函数名和函数接收的变量之后，我们有可见性声明、状态可变性和函数的返回类型。

对于可见性，我们可以有公共、私有、内部和外部。对于状态可变性，我们可以有纯的、视图和可支付的。为了在函数的最后返回一些变量，我们应该添加关键字' return s ',并在括号中加上我们想要返回的变量类型。这里我们可以返回多个变量，所以要记住这一点。

好，让我们更详细地看看不同类型的可见性。正如我们所说的，我们有四种不同类型的可见性——公共的、外部的、内部的和私有的。

这些可见性声明可以应用于函数和变量，但 external 关键字除外，它只适用于函数。

当我们声明一个函数时，它的默认可见性是 public。我们可以在内部和外部调用这个函数，每个人都可以访问它。

![](Image00015.jpg)

external 关键字的作用几乎是相同的，但是，当您尝试在内部调用函数(从合约内部或合约中的另一个函数)时，您将需要使用' this '才能访问它。

这似乎有点不方便。然而，外部函数有时会消耗较少的气体，因为当它们接收大量数据时，有时会更有效。

我们还可以拥有只能从当前合约或从它派生的合约内部访问的内部函数。

最后但同样重要的是，我们有私有函数，这些函数只能从定义它们的合约中调用。它们只能在同一合约中内部使用。

现在让我们看一个外部和公共函数的例子。

这是我们的合约样本。

![](Image00016.jpg)

在第一行，你可以看到我已经声明了一个外部变量。如果你试图这样做，你会得到一个错误，合约不会编译。记住，状态变量没有外部可见性。

但是，这里我创建了公共函数和外部函数。两者做的操作是一样的，只是外函数最后会少花点气。外部函数在接收大量数据时效率更高，因此您可以使用它们来提高合约的效率。

最后，我声明了一个函数，在这个函数中，我尝试调用外部函数 test2。然而，我需要将其指定为 this.test2()，以便在内部访问外部函数。

所以记住如果要内部调用外部函数，需要加上关键字 this。在函数前面。

现在，让我们看一个内部和私有函数的例子。

![](Image00017.jpg)

这里我们有三个合约 C，D 和 e。

合约 C 有一个私有函数、两个公共函数和一个名为 compute 的内部函数。

在合约 D 中，如果我们试图调用合约 C 中的函数 f，我们将会得到一个错误，因为这个函数被声明为私有的，并且只在定义它的合约中可见。

同样，如果我们试图从合约 D 调用函数 compute，我们也会得到一个错误，因为合约 D 不是合约 c 的派生物。

然而，合约 E 是 c 的派生物，我们用关键字‘I s’声明它，正如你在例子中看到的。如果你有任何编程知识，这被称为继承。

因为，我们的合约是合约 C 的派生物，我们现在可以调用计算函数，因为它是内部成员。

现在，让我们谈谈函数的状态可变性。

![](Image00018.jpg)

我们有三种不同的修饰词。

我们有风景，纯粹的和可支付的。

如果我们声明一个函数是视图函数，我们基本上保证不修改状态。

纯函数是视图函数的导数。然而，纯函数不仅保证不修改状态，还保证不从状态中读取。在接下来的幻灯片中，我们将看到对这些功能的更具体的限制。

我们能拥有的最后一种状态可变性是可支付的。基本上，用这个修饰符标注的函数可以接收以太，并且可以用这些以太进行操作。

现在，让我们来看一些例子。

以下是您可以创建的视图函数的示例:

![](Image00019.jpg)

这个函数接受两个变量“a”和“b ”,并返回“a”乘以(b + 42) + now。

Now 是一个全局变量，它以时间戳变量的形式给出现在的时间。

当你有一个视图函数时，你不能写状态变量，发出事件，发送以太，调用非纯或视图的函数等。我已经在右边列出了视图函数中不允许的东西。

没有。纯函数和视图函数有相同的限制，并且它们不能读取表单状态变量

![](Image00020.jpg)

在这个例子中，我们有三个纯函数。前两个函数接受变量 x 和 y，进行一些数学运算并返回结果。第三个只是返回一串“你真棒！”。这些是你可以使用的纯函数的完美例子。

然而，有一些额外的限制，你应该记住，像你不能访问这个。未标记为纯的 balance、blocks、tx、msg 变量或调用函数。

现在让我们来看一个支付函数的例子:

![](Image00021.jpg)

为了接收以太网，你需要向一个函数提供“payabl e”关键字，否则该函数将拒绝所有发送给它的以太网。

在这个示例合约中，我们有一个公开声明的可变金额 0，我们有一个可支付函数 pay me。变量 msg.value 给出了发送给函数的乙醚量，并将其添加到变量 amount 中。

这是在区块链以太坊创造的代币的基础。实际上，事情要复杂一点，但基本原理是一样的。所以让我们就此打住，在下一堂课上进行一些练习。

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

好了，在这堂课中，我们将简要地看一下在线 IDE，我们可以用它来制定我们的可靠性合约并快速测试它们。

所以，你需要打开 [remix.ethereum.org](https://remix.ethereum.org/)

What Is Remix And How To Use It?

![](Image00022.jpg)

这里我们可以看到一个已经写好供我们测试的样本合约。

然而，我们将开始写我们自己的合约。

现在，我希望您点击网站左上方的加号。

给实体文件起一个你喜欢的名字。我将命名我的信使。

正如我们在上一讲中讨论的，在每个 solidity 文件之上，我们需要所谓的版本杂注。所以键入‘pragma solidity ^0.4.2 4’；

![](Image00023.gif)

这是目前为止最新的固体。

此外，下面我们将定义我们的合约。键入合约信使和花括号。

在第一行，我们将定义一个名为 owner 的变量地址。在下节课中，我们会更多地讨论变量，所以请耐心听我说。

所以，我们键入地址私人所有者；

在下一行，我们将定义一个名为 messages 的字符串数组。

就在我们声明的变量下面，我们将定义一个构造函数。

类型构造函数开括号和闭括号，公共的开括号和闭括号。

在花括号内，我们将输入 owner = msg.sender。

这一行将所有者定义为部署合约的人。

在下一行中，我们将定义一个函数 add，其输入变量是一个名为 newMessage 的字符串。

可见性将是公开的，我们将打开和关闭花括号。

在括号内，我们将键入以下内容

require(msg . sender = = owner)；

这一行将防止任何不是合约所有者的人向数组消息中添加消息。

在接下来的课程中，我们会更详细地讨论这个问题。

在它下面，我们将输入 messages . push(new message)；

这一行将向消息数组中添加一条新消息。

下面我们将定义一个名为 count 的函数，它是一个视图公共函数，返回一个 uint。

在花括号中，我们将返回 messages.length，这将返回数组中的消息数。

在此之下，我们将定义最后一个名为 getMessage 的函数，它将接受一个名为 index 的变量 uint。

该函数将是一个视图公共函数，它将返回一个字符串。

在函数内部，我们将返回包含我们给函数的索引的消息。

好了，现在我们准备编译我们的合约，并将其部署到虚拟网络。

我们需要点击这里的编译按钮，然后点击开始编译。

![](Image00024.jpg)

我们得到一个绿色的 Messenger，这意味着我们的代码中没有错误。

如果您有任何错误或警告，您会在这里看到一些黄色或红色的通知。

他们非常明确地指出错误是什么，这样你就可以纠正它。

好了，现在我们可以继续这里的“运行”选项卡。

![](Image00025.jpg)

在顶部，我们有一个名为“环境”的下拉菜单。

我们有 3 个选择——JavaScript VM、注入式 Web3 和 Web3 Provider。

我们准备选择 JavaScript 虚拟机。

在这下面，我们有 5 个虚拟以太坊钱包。之后，我们要发送到一个函数的事务和 blow 的气体限制。

![](Image00026.jpg)

在这下面，我们有一个在 solidity 文件中的合约下拉列表。目前，我们只有一个名为 messages 的合约，所以我们选择它。

d …我们单击部署。

现在，我们可以看到，我们已经成功部署了我们的合约，并且我们可以访问以下功能——添加、计数和获取消息

在这里的调试器控制台中，您可以看到关于部署的更多细节。

![](Image00027.jpg)

您可以看到交易的状态是成功

您可以看到合约地址和谁部署了合约，以及关于天然气和输入的其他详细信息。

好了，现在让我们尝试向我们的 messenger 添加一条消息。

Le t 在此处键入引号中的“第一条消息 e”。不要忘记加上引号，否则你会出错。这就是这里输入字符串的方式。

现在，让我们单击 add 按钮，看看会发生什么。

如你所见，交易是成功的。

![](Image00028.jpg)

我们将这个输入提供给函数 Messenger.add

现在让我们检查一下计数。

我们的信使中有一条信息。

现在让我们尝试返回此消息。

在 getMessage 函数中键入 0，然后点击按钮。

这里你可以看到我们有一个调用函数，它给了我们一个“新消息”的输出

然而，如果我们试图返回一个不存在的索引，我们将得到一个错误。

让我们试着输入 1 并点击 getMessage。

在这里，您可以看到我们得到一个无效操作码的错误。

我想再给你看一样东西。

还记得我们在这里将 add 函数限制为只能由合约所有者使用吗？

现在让我们将帐户更改为另一个帐户，并尝试添加消息。

![](Image00029.jpg)

让我们用引号将“测试消息”括起来，然后点击“添加”按钮。

如你所见，我们得到一个错误，回复。交易在此停止，并且不让我们将消息推送给信使，因为我们不是所有者。

好了，现在你已经创建了你的新合约，并且对混音 IDE 有点熟悉了。

现在，让我们继续我们的讲座，更深入地了解可靠性。
T9

更新:对于任何想在新版本的 solidity ^0.5.1 中使用它的人，请使用下面的代码。不同的是，我们需要明确地指定我们的字符串是内存变量:
![](Image00030.gif)

【codingsrc.com/solidity】在
获得关于坚实度的免费视频课程

好了，现在在这个视频中，我们将讨论固体的不同变量。

Solidity 是一种静态类型语言，这意味着需要指定每个变量的类型

Variables in Solidity

你应该记住的最重要的值类型是布尔值、整数、地址、字节、字符串、十六进制和枚举

![](Image00031.jpg)

如您所知，布尔是一种只有两种可能值的数据类型——真或假。在 Solidity 中，我们用关键字 bool 来定义它们。

然而，实性中的整数更有趣一些。

如果你不知道，整数是没有小数部分的数字；它可以是正数、负数或零。

这里，它们用 8 到 256 位来定义，可以是有符号的，也可以是无符号的。

有符号可以有正值和负值。

至于无符号的，里面只有正数。

在可靠性方面，我们现在没有十进制或浮点数。

定点数在文档中被定义为定义十进制数的一种方式，但是，带有一个大的警告标志，表明它们还不被完全支持。所以，现在我们没有十进制数值，但是请记住，将来这可能会改变。

现在...地址类型包含一个 20 字节的值，这是以太坊地址的大小。

地址也有成员，并作为所有合约的基础。

我们还有字符串类型，用双引号或单引号写，可以保存文本。十六进制类型保存十六进制字符串，枚举值是在 Solidity 中创建用户定义类型的一种方式。

现在让我们更详细地看看整数类型:

![](Image00032.jpg)

正如我所说，整数可以有符号和无符号。

有符号整数用关键字 int 定义，无符号整数用关键字 uint 定义。

整数以位为单位定义，从 8 到 256，步长为 8。

在此表格中，您可以看到最小值和最大值。

请记住，如果您定义的整数末尾没有数字，只有 uint 或 int，那么它们分别是 uint256 和 int256 的别名。

你有责任优化你的代码，所以根据你的需要使用相应的大小。你可以自己决定是使用 uint8 还是 uint256(或者任何大小),这取决于你所期望的数字是大还是小。

因此...对于整数，你可以进行比较、位和算术运算，如下表所示。

请记住，在其他编程语言中，您可能会遇到数字上溢或下溢的情况。例如，如果你定义一个等于 0 的 uint256，然后从这个数中减去 1，你会得到这个大的数。

![](Image00033.jpg)

这可能会给你带来很多麻烦，所以要小心。

我们要讨论的下一个变量是地址变量。地址是以太坊的地址。

![](Image00034.jpg)

对于每个地址变量，我们有以下成员。

我们有余额，这给了我们在魏的地址余额。

我们有汇款系统，可以把一定数量的钱汇往一个地址。

我们派人去做同样的事。但是，这里的区别在于，如果失败，transfer 抛出，如果失败，send 返回 false。否则，两者做同样的事情。

我们还有呼叫、呼叫代码和委托呼叫，这些都是低级呼叫。

我们将暂时跳过这些地址成员的工作，但请记住它们是存在的。

![](Image00035.jpg)

我们还有字节，它是数据的二进制表示。

如您所见，我们可以从字节 1 到字节 32 使用固定大小的字节。

它们分别存储 1 到 32 位的数据。

每当我们想优化我们的合约以提高成本效率时，我们都希望使用字节而不是字符串。

通常在运行一个函数时，使用字符串而不是字节会消耗更多的时间。

使用字节而不是字符串的第二个原因是智能合约到智能合约的关系。Solidity 仍然不能返回字符串作为其他合约的函数结果。

这可能看起来真的没有必要知道，但智能合约每天都变得越来越复杂，并且越深入，区块链上就会出现越多的合约对合约关系。

最后，我们将看到字符串，十六进制和枚举。

![](Image00036.jpg)

字符串是由双引号或单引号组成的字符序列，如本例所示。

十六进制文字以关键字 hex 为前缀，用双引号或单引号括起来，并保存在字节变量中。

最后还有枚举，它们是 solidity 中的用户自定义类型。正如你在这个例子中看到的，你可以创建一个名为 Action Choices 的枚举，包括向左走、向右走、直走和静坐。当一个变量(尤其是一个方法参数)只能从一小组可能的值中取一个值时，你应该总是使用枚举。

好了，现在我们知道了固体的基本类型。让我们继续下一节课，再次练习混音。

[在
codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

混音练习:变量

# 在这节课中，我们将会有一些混合变量的练习。

# 打开混音并创建一个新的实体文件。

我们将其命名为变量示例，然后按 enter 键。

和往常一样，我们需要在顶部放置版本杂注。

所以，务实型^0.4.24；

之后，创建名为 VariableExamples 的合约。

现在让我们定义一些变量。

键入 bool switchedOn = true

在此类型下，地址所有者= msg.sender

在那之后 uint8 数= 8；

在它下面是一个 bytes32 变量，名为 awesom1 = " Solidity 太棒了！"

紧接着是一个名为 awesome2 的字符串变量，包含相同的文本；

![](Image00037.jpg)

现在让我们来编译和部署我们的合约。

点击编译后，进入运行和部署。

嗯……我们已经成功部署了我们的合约。然而，我们无法看到这些变量，也无法以任何方式与它们互动。

如果你们还记得在之前的课上，我告诉过你们，我们可以让变量和函数都可见。

当我们声明一个变量时，默认的可见性是内部的。

这意味着变量只能在合约及其衍生合约内部访问。

所以让我们将变量改为 public，看看会发生什么。![](Image00038.gif)

在这里为每个变量键入 public，然后重新编译协定。

现在，在我们部署它之前，让我们删除以前的实例，然后重新部署合约。

正如你现在看到的，我们可以看到所有的变量都是可访问的，我们可以返回值。

记得我在上一讲中说过，字节比字符串值更划算。

让我们来看看调用字符串和字节变量要花多少时间。

如你所见，字节变量比字符串变量消耗的气体少。

既然你已经看到了这一点，让我向你展示一个你可能陷入的陷阱。

让我们创建一个名为 OverflowAndUnderflow 的新文件。

在文件的顶部，让我们指定我们的版本 pragma。

之后，让我们创建合约。

![](Image00039.gif)

在里面我们将指定一个叫做溢出的函数。

该函数将是一个公共的纯函数…它将返回一个 uint256。

在内部，我们将声明一个名为 max 的变量 uint256，它等于 2 的 256 的负 1 次方。

在坚固性方面，像这样使用双星将使数字达到另一个数字的幂。

这将为我们提供 uint256 的最大值。

如果我们返回 max + 1，让我们看看会得到什么。

让我们编译合约并部署它。

现在让我们调用函数 overflow，看看会得到什么。

我们得到 0 的值。

反之亦然，称为下溢。

让我们复制这个函数，把它的名字改成下溢，并删除里面的所有内容。

让我们创建一个名为 min 等于零的 uint256。

它正下方返回 min 减 1；

让我们重新编译一下合约

之后，转到运行选项卡，首先删除以前的合约。

现在再次部署合约。

让我们点击下溢函数，看看我们得到了什么。

我们得到单位的最大值。

这是你应该记住的关于整数的最重要的事情之一，因为这会给你带来很多麻烦。

毕竟我们是在和钱打交道，我们需要确保无论何时我们做一些数学运算，我们都不会溢出或下溢变量。

好了，现在我们看到了如何在合约中暴露变量，以及整型变量的危险。

让我们在下一段视频中继续我们的讲座。

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 的
获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

getter 和 setter

# 在这节课中，我们将讨论 solidity 中的 getters 和 setters。

# 如果你以前没有听说过 getters 和 setters，这里是它的定义

getter 是一个获取特定属性值的函数。setter 是一个设置属性值的函数

让我们看一个 getter 函数的例子。

![](Image00040.jpg) 在这里你可以看到一个带有两个数字的合约样本——公众号和秘密号。

第一个数字是公开可见性，第二个数字是私有可见性。

正如我在上一讲中展示的，公共变量自动得到一个 getter 函数，所以如果你想访问一个变量，你可以把它变成公共变量。

你也可以创建一个像这样的函数，叫做 getSecret，当然它需要是公共的，它可以返回私有或内部变量，并公开它们。

现在让我们看一个二传手的例子。

这里我们有一个包含私有变量消息、getter 和а setter 的消息合约。

![](Image00041.jpg)

使用 setter，您可以将私有变量的值更改为您想要的任何值。

现在让我们进入 [混音](https://remix.ethereum.org/) ，看看 getters 和 setters 的工作情况。

让我们创建一个名为 GettersAndSetter 的新文件，然后按 enter 键。

像往常一样，在顶部键入版本杂注。

让我们从演示中复制并粘贴 MessageContract，看看它是如何工作的。

现在编译合约并部署它。

这里有两个可用的函数——getMessage 和 setMessage。

如果我们点击 getMessage，我们将得到预定义的“Hello Worl d”消息。

让我们试着用二传手来改变这一点。

键入引号“更改的消息”并点击设置消息。

该功能已成功执行。

现在让我们看看我们是否改变了消息的值。

再次单击 getMessage，如您所见，我们已经更改了它的值。

现在你知道 getters 和 setters 是如何在 solidity 中工作的了。

让我们继续下一堂课，更深入地探讨可靠性

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

阵列

# 在这节课中，我们将讨论数组。

# 如果你不知道数组是什么，它们是一系列大小和类型都相同的对象。数组中的每个对象称为一个数组元素。

例如，你可以有一个整数、字符串、字节等的数组。

要定义数组，您应该键入变量类型并在其后加上方括号。

你访问一个数组的元素，它的顺序位置从 0 开始。例如，数组的第三个元素是数组名和方括号中的数字 2。

数组可以有固定的大小，也可以是动态的。

![](Image00042.jpg)

这里我们有一个固定大小数组的例子。

我们有一个样本合约，其中有一个固定大小为 3 的数组，称为 nums。

在数组中，我们预定义了数字 10、20 和 30。

在这下面，我们有一个名为 getNums 的函数，它将返回数组

然而，在我们返回它之前，我们想改变它的值。

在这里的第一个地方，我们将把数字 11。

我们用 22 代替第二个数字，用 33 代替第三个数字。

之后，我们返回包含新数字的数组。

最后，我们有一个函数 get length，它将返回数组中元素的数量。

现在让我们看一个动态数组的例子，看看我们有什么。

要定义动态数组，您应该将方括号留空。

![](Image00043.jpg)

在动态数组中，您现在可以访问 push 成员，它将一个元素添加到数组的末尾。

正如你在这里看到的，我们在分数合约中有一个添加分数的功能。

这会给数组添加一个新的分数。

在这下面，我们有一个函数 get length，它给出了数组中元素的数量。

最后我们有一个清晰的数组函数。

要使用它，只需键入 delete 关键字和数组名称，它将删除数组中的所有元素，并将其留空。

现在你对 [再混合](https://remix.ethereum.org/) 有些熟悉了，你将有任务在那里打那两份合约。

部署每份合约并试验阵列。

尝试使用 push 成员将数组元素添加到动态数组中，检索数组的长度并删除数组。

此外，尝试更改固定大小数组的值，并按位置检索元素，如示例所示。

之后继续下一讲。

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

内存 vs 存储

# 好了，在这堂课中，我们将会讨论 solidity 在哪里存储变量，以及它是如何处理变量的。

# 更具体地说，我们将讨论内存和存储的区别。

![](Image00044.jpg)

合约的存储变量是定义合约状态的变量，只能通过事务调用来改变。

内存变量是只存在于调用函数内部的临时变量。它们会在函数退出后被清除，并且通常比存储变量更便宜。

所以基本上你应该把存储和内存变量想象成 RAM 和硬盘。

内存使用当前进程或函数的变量，并在使用完变量后释放它们。

对于存储，你应该想象我们在硬盘上写一个文件并保存在那里。

不，我们定义的状态变量是默认存储，函数参数是默认内存。

现在让我们来看看这个示例合约:

![](Image00045.jpg)

如你所见，我们有一个状态变量数组和三个函数

我们有一个名为 start change 的函数，它调用另外两个函数。

然而，名为 first change 的第一个函数有一个显式定义的存储变量作为参数。

第二个函数叫做“第二个常娥”,默认的函数参数是内存。

在这两个函数中，我们都想尝试改变数组中的第一个元素。

你认为在我们运行函数 start change 之后，数组的第一个元素会是什么？

你可以在这里停下来，把合约复制到 remix 来测试一下。这对你来说是一次很好的锻炼。

如果你在 Remix 中测试，你会知道答案是 4。但这是为什么呢？

这是因为当我们给一个函数一个变量时，函数会复制这个变量，并用这个副本做所有的运算。

函数完成后，它销毁变量。

如果我们明确地定义一个函数参数为存储，我们就是说我们想对我们引用的变量做所有的操作。

不要复制；使用我给你的存储变量。

这就是为什么“firstChang e”函数对数组进行了更改，而第二个函数似乎没有进行任何更改。

现在你对记忆和存储有了更多的了解，让我们继续下一堂课。

[在
【codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

映射 映射

# 在这节课中，我们将讨论实性中的映射

# 在 solidity 中，映射指的是具有所谓的键类型和值类型的哈希表。

您可以在其他编程语言中与键值对建立关联。

映射用于构造值类型，如布尔值、整数、地址、结构等。

最重要的是键必须是相同的类型，值也必须是相同的类型。

所以你可以有只有地址的键和只有整数的值，就像这样。

![](Image00046.jpg)

现在，如您所见，我们有一个名为“银行”的合约和一个名为“帐户”的映射。

我们用关键字 mapping 来定义我们的映射，在括号中，我们首先放置键类型，然后是箭头，然后是值类型。

之后是映射的可见性和名称。

如您所见，用 public 标记映射是可能的。

这将使坚实创造一个吸气剂。

键类型将成为 getter 的必需参数，它将返回值类型。

您还应该记住，映射只能对键使用基本类型。

基本类型有地址、uint、字节、字符串和 bool。

然而，我不认为你想使用 bool 作为一个键，因为它只有两个可能的值。

在它的正下方，我们有存款和取款两个功能

在这里你可以看到，我们得到的映射值就好像它是一个数组。

我们给出调用该函数的人的地址，这样只有他才能向自己的账户存款。

取款时，我们也会从汇款人的账户中扣款。

现在让我们看一个简单的象征性合约。

![](Image00047.jpg)

在这里，您可以看到，我们已经定义了具有关键地址和值 uint256 的映射帐户。

在构造函数中，我们提供令牌的初始供应，并将它们添加到创建者的帐户中。

下面我们定义了一个传递函数，它可以将令牌发送到所需的地址。

然而，首先我们检查我们有足够的令牌来传输，然后，我们检查溢出。(我们将在后面的讲座中讨论这些限制)

在那之后，我们进行交易。

我们从所有者帐户中减去金额，然后将它们添加到给定的地址。

这堂课的作业是将这份合约复制并重新混合，然后在此基础上构建。

创建一个函数，返回某个帐户地址的余额。

我们还需要一个函数，返回我们可用的令牌供应。

最后，您可以尝试创建一个 payable 函数，该函数将接收以太网，并根据您可以得出的固定汇率向发送方发送令牌。

分配摘要:

继续复制合约，并在 [https://remix.ethereum.org](https://remix.ethereum.org/) 进行测试

创建一个返回某个账户余额的函数

1.  创建一个返回可用令牌供应的函数
2.  创建一个可支付的函数来接收以太，它将发送令牌给发送者。
3.  你做完后，继续下一节课。
4.  [在 codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

结构

# 在这节课中，我们将讨论 solidity 中的结构类型。

# 不，坚固性给了我们一种以结构的形式定义新类型的方法。

它们基本上就像内部具有不同类型特征的物体。

结构类型可以在映射和数组中使用，并且它们本身可以包含映射和数组。

您应该记住的一点是，尽管结构本身可以是映射成员的值类型，但结构不可能包含自己类型的成员

比如这里的合约银行。

![](Image00048.jpg)

我们已经创建了一个名为 account 的结构。

里面有地址和金额的无符号整数。

现在我们已经定义了新的变量类型，我们可以初始化它了。

这里我们定义了一个公共帐户，值为这个地址，金额为 50。

现在，如果你想访问一个结构体的成员，你可以用点和你想访问的成员的名字。

我们已经定义了一个函数 addAmount，它将钱添加到帐户的金额中。

现在你的工作将是在 solidity 中复制合约，并测试当我们调用 account getter 时，如何在那里接收 struct 类型。

您还应该尝试 addAmount 函数并添加一个取款函数，该函数将从帐户中扣款。

如果你想让它更上一层楼，你应该用不同的地址再创建一个账户，再创建一个名为 transfer 的功能。

转移函数应该有一个接收要转移的钱的 uint，并且应该从第一个帐户中扣除钱，然后将它们添加到第二个帐户中。

现在停在这里，去混音室做你们的作业，然后回来继续上课。

分配摘要:

复制合约，并在混音中进行测试

使用“添加金额”功能向账户添加金额

1.  创建一个从账户中扣款的函数“withdra w”
2.  再创建一个帐户
3.  创建一个函数转移，从第一个账户中扣除资金，并将它们添加到第二个

4.  [在 codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

错误处理&限制

# 在这堂课中，我们将讨论 solidity 中的错误处理和异常。

# Solidity 使用状态恢复异常来处理错误。

当我们有这样的异常时，所有的改变将撤销到当前调用的状态。

我们有三个函数可以做到这一点。断言、要求和恢复。

让我们先来看看限制条件的最常见的方法--函数要求。

Require 主要用于验证用户输入和外部合约响应。

让我们在这里查看一下我们的示例合约:

![](Image00049.jpg)

我们有合约银行，和前面讲的一样，有存取款功能。

但是，如果用户希望存入的金额超过 uint256 的最大值会怎么样呢？

没错。数字溢出。我们在关于变量的讲座中提到过这一点。

这就是为什么我们希望限制我们的用户输入是有效的。

在第一个函数中，我们确保每当我们试图向帐户添加钱时，金额实际上都会增加。

该要求功能将防止溢出，如果条件不满足，它将把所有剩余气体以及与交易一起发送的乙醚返回给发送方。

如您所见，我们还可以提供一条错误消息，如果条件不满足，调用者可以收到这条消息。

在我们的情况下，这是“溢出错误”。

在第二个函数中，我们只想确保我们要提取的钱少于或等于帐户余额。

这样我们就不会提取比我们账户里更多的钱，也不会让我们的余额下溢到一个大得离谱的数字。

现在让我们来看看另一种方法——函数 revert:

![](Image00050.jpg)

revert 的工作原理与 require 函数基本相同，但是，当满足更复杂的 if 条件时，它可以用作一个标志。

在 require 函数中，您只有一行可以输入您的条件。

使用 revert，您可以使用 if else 语句进行一些复杂的检查，当您使用 revert 函数时，它会使事务返回到以前的状态。

也没有改变的事实是，恢复以及要求退还所有剩余的天然气。

不，让我们看看断言函数的例子。

![](Image00051.jpg)

这里我们有一个合约数学的例子，它有两个函数…加法和乘法。

根据文档，assert 函数应该只用于测试内部错误和检查不变量

如你所见，我们的函数是内部的，我们用 assert 函数来防止数字溢出。

如果我们给函数 add 一个比 uint256 的最大值更大的数，assert 将使事务无效。

但是，您应该记住 assert 将使用所有剩余的气体。

您应该使用 assert 来避免不应该出现的情况。

您应该记住的一点是，assert 在做出更改后验证状态。

现在我为你做了一个小的备忘单，你可以看看，以便更好地理解这些函数之间的区别。

One thing that you should remember is that assert validates state after making changes.

![](Image00052.jpg)

你这堂课的作业是，回到你现在已经达成的合约，考虑你可以对你的用户输入和数字做出的限制。

有没有可能溢出或下溢某个数字的函数，或者您是否希望只有合约的所有者才能访问这个函数？

使用适当的函数来限制这种情况的发生，然后继续下一堂课。

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

库 库

# 在这个讲座中，我们将谈论图书馆及其功能。

# 实际上，图书馆是一种不同类型的合约，它没有任何存储空间，也不能容纳以太。

因为它们没有存储空间，所以也没有状态变量，不能继承也不能被继承。

库基本上是一段代码，可以附加到变量上，并使用预定义为给定类型成员的函数。

我们用关键字 library 和其后的引用名来定义一个库。

现在我们有一个非常受欢迎的库，叫做安全数学。

![](Image00053.jpg)

这个库防止数学运算使数字上溢或下溢。

如你所见，我们有乘法、除法、减法和加法。

然而，我们如何使用库呢？

让我们看看如何在我们的可靠性合约中使用它。

![](Image00054.jpg)

如你所见，我们可以直接从 GitHub 导入库。

只需使用 import，库的名称和库文件的链接。

您也可以通过提供文件的目标位置，将库作为本地文件导入。

之后，我们定义我们将把这个库附加到 uint256 变量类型上。

现在我们可以作为变量 uint256 的成员访问库中的所有函数。

虽然在库中我们需要两个参数，但是我们使用的变量被接受为第一个参数，第二个参数是括号中的那个。

这同样适用于这里的减法函数。

现在你知道如何在 solidity 中使用库了。

为了测试它，从 GitHub 导入安全的数学库，放在你之前签订的合约中。

将 SafeMath 附加到 uint256 变量，并更改所有数学运算以遍历库函数，如示例所示。

这将防止你的数字上溢和下溢。

做完后，去听下一堂课。

【codingsrc.com/solidity】在
获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

修饰符

# 现在我们来谈谈修饰语。

# 在 Solidity 中，我们可以创建自己的修饰符，只需在函数中添加 modifier 关键字，就可以改变函数的行为。

例如，它们可以在执行函数之前自动检查条件。

![](Image00055.jpg)

在这个样本合约中，我们定义了一个名为 onlySeller 的修饰符。

我们用关键字修饰符和我们想要创建的修饰符的名称来定义它。

在花括号中，我们定义了每当我们有这个修饰符时，我们希望函数检查或做什么。

通常修饰符用于限制，这样可以节省我们在每个函数中都写一行 require 的时间。

然而，它们的用途不止于此。

现在，在函数中要执行的代码行之后，我们放置了一个下划线和分号。

这就像是函数代码的占位符。

然而，不要混淆。

你可以先有下划线，然后是一些代码。

或者，你可以有一些代码，占位符，然后是一些代码。

现在我们把这个修饰符作为一个函数的其他修饰符来应用，就像这里。

每当这个修饰符被应用到一个函数时，它将总是检查用户是否是销售者，如果不是，它将返回。

现在让我们看另一个例子。

![](Image00056.jpg)

您需要记住的一点是，修饰符是合约的可继承属性，可能会被派生的合约覆盖。

这意味着，如果您有一个带有修改量的合约，并且另一个合约继承了此合约，您将能够访问修改量并在那里使用它们，如示例所示。

这里我们有两个合约，一个是所有者合约，另一个是凡人合约，凡人合约继承了所有者合约。

这意味着在致命合约中，我们可以使用修饰符 onlyOwner 而不用定义它。

现在你的任务是检查你以前的合约，你应用了你的限制。

考虑在哪里可以应用 onlyOwner 的限制，并为此创建一个修饰符。

之后，将修饰符应用于只需要由所有者执行的功能。

完成作业后，继续下一堂课。

[在 codingsrc.com/solidity](http://codingsrc.com/solidity) 的
获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

全局变量

# 在这堂课中，我们将讨论固体中的全局变量。

# 有许多预定义的变量，我们可以直接使用它们，

首先，我们要看一看我们拥有的以太单元。

如果你不知道的话，以太坊有一个公制的名称系统作为以太的单位。

每一个单位都有自己独特的名字，但是最小的单位也就是以太的基本单位叫做“微”。

有许多不同的单位，但在坚固性上，我们只有芬尼萨伯，乙醚和魏，我们可以使用。

这里你可以看到他们的转换率。

![](Image00057.jpg)

现在...我们也有一些可以使用的时间单位。

下面是 solidity 中的时间单位列表。

![](Image00058.jpg)

我们有秒、分、小时、天、周。我们过去也有年，但现在已经过时了，因为不是每一年都有 365 天。

我们还将块和事务属性作为全局变量。

![](Image00059.jpg)

如您所见，我们有 3 个主要变量 block、msg 和 tx

在 block 变量中，我们有 blockhash、coinbase、difference、gaslimit、number 和 timestamp 等成员。

这里每个变量都有明确的解释，但是，最常用的变量是返回现在时间的时间戳——与 now 变量相同，它是一个别名。

对于消息变量，最重要的是 msg.sender 和 msg.value，前者返回消息的发送者地址，后者返回发送呼叫的 wei 的号码。

我们还在 Solidity 中集成了加密和数学功能:

![](Image00060.jpg)

我们有 sha3，它与 keccak256 hash、sha256 和 ripemd160 相同，可以加密我们的输入。

我们还有像 addmod 和 mulmod 这样的数学函数，它们分别返回两个数相加和相乘的模运算。

最后但同样重要的是，我们有与合约相关的全局变量。

![](Image00061.jpg)

我们有 this 关键字，它与当前合约相关，并且可以显式地转换为 address。

我们也有自毁，它破坏当前的合约，并将其资金发送到给定的地址。

自杀是自毁的废弃别名。

现在，你简要地看了一下我们可以拥有的全局变量。

现在让我们继续下一节课。

【codingsrc.com/solidity】在
获得关于稳健的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

抽象合约，继承&接口

# 现在我们将讨论 solidity 中的抽象合约、继承和接口

# 如果你没有其他编程语言的抽象类的先验知识，我们用它们来提取合约之间的共同特征，这样我们就不会有重复的代码。

如果我们想改变所有合约共有的东西，这将对我们有很大帮助，我们将只在抽象合约中改变它一次，它也适用于衍生合约。

解释这一点的最佳方式是看一下这个例子:

![](Image00062.jpg)

这里我们有一个抽象的合约动物，它定义了公共变量品种、年龄和体重。

我们还创建了一个默认的构造函数，如果我们不覆盖它，我们的年龄为 1，权重为 1。

我们还有两个实现的函数 sleep 和 eat，以及一个未实现的函数 talk。

当合约中至少有一个函数缺少实现时，它们就被标记为抽象的，就像我们的例子一样。

注意，抽象合约中的函数 talk 以分号结束。

这是抽象合约的设计者说“我的任何一个孩子都必须实现这些函数”的一种方式。

![](Image00062.jpg)

现在，合约 Cat 和 Dog 实现了带有关键字“I’s”的抽象合约，它们继承了已实现的函数 sleep、eat，并且有义务覆盖 talk 函数。

我们还覆盖了定义品种、年龄和体重的构造函数和变量。

现在让我们看看抽象合约和接口之间的区别。

![](Image00063.jpg)

我们用关键字 interface 而不是 contract 来定义它们，然后给出引用名。

我们也有一些限制，比如他们不能继承其他合约或接口。

它们不能有带实现的函数或已定义的构造函数。

我们也不能在接口中定义变量、结构和枚举。

基本上你应该把一个接口想象成我们合约的骨架。

我们定义在继承接口的合约中需要什么样的函数。

当合约继承一个接口时，它需要实现它的所有功能。

如你所知,“i s”关键字意味着我们的合约继承了一个接口或一个合约。

坚固性支持多重继承。

![](Image00064.jpg)

当一个合约继承多个合约时，在区块链上只创建一个合约，所有基础合约的代码都被复制到创建的合约中。

当你想继承多个合约或接口时，你需要用逗号把它们分开。

同样在这个例子中，我们有一个继承多个合约的合约。

如果合约的构造函数之一接收参数，就需要在头中指定它，正如您在这里看到的。

现在我们对抽象合约、接口和继承有了更多的了解。

让我们继续下一讲。

[在
codingsrc.com/solidity](http://codingsrc.com/solidity) 获得关于坚实度的免费视频课程

[Get FREE Video Lessons on Solidity at
codingsrc.com/solidity](http://codingsrc.com/solidity)

事件 事件

# 在这节课中，我们将谈论一些事件。

# 事件是通过 JavaScript 回调告诉我们的分散式应用程序已经发生了一些事情的好方法。

我们也可以在活动的同时发送信息。

为此，我们首先需要用关键字 event 预定义我们的事件，然后是事件的引用名。

![](Image00065.jpg)

在括号内，我们指定当 DApp 捕捉到事件时，我们希望将哪些变量发送到我们的 DApp。

我们还可以用关键字 indexed 指定最多三个变量，这将导致搜索相应的参数。

这样就可以在用户界面中过滤索引参数的特定值。

现在，当我们想要发出事件时，我们使用 emit 关键字和特定事件的引用名。

在括号内，我们给出想要传递给 UI 的参数。

在应用程序的 JavaScript 端，我们将监听这些事件，捕捉它们并接收我们传递的参数。

我们将在课程的下一部分更详细地讨论这一点。

现在，如果我们在 remix 中复制这个合约并运行函数，我们可以测试我们的事件是否正常工作。

所以我们去把这个合约重新混音粘贴，编译一下。

现在让我们从这里的下拉菜单中复制另一个电子钱包地址。

![](Image00066.jpg)

现在让我们存一些钱到那个账户上，看看我们会收到什么。

让我们输入 100 枚货币，粘贴钱包地址，然后点击存款。

现在，正如您所看到的，我们成功地执行了事务，并且有了一个名为 logs 的新表行。

在这里，您可以看到我们在事务期间发出的所有事件及其详细信息。![](Image00067.jpg)

在这里，您可以看到我们从中发出事件的合约，主题是事件及其使用 sha3 加密的参数。

在这种情况下，我们只发出一个名为存款的事件。

但是，如果我们在这里有多个事件，它们将被逗号分隔，并像 JSON 数组一样显示在这里。

如你所见，我们有事件的名称和参数，可以通过名称或位置来访问。

最后是长度，它给出了事件中参数的数量。

现在你知道了事件的基本情况，以及我们能从 DApp 的合约方面做些什么。

在接下来的讲座中，我们将更详细地讨论如何用参数捕捉这些事件，并在我们的分散式应用程序中显示它们。

现在，对于一个任务，你将不得不复制这个合约，并在 remix 中使用它，并查看当我们产生一个事件时的日志行。

您需要创建一个新的简单事件，并在存款函数中发出它。

这样，您将能够看到如何在日志行中获得多个事件。

You will need to create a new simple event and emit it inside the deposit function.

This way you will be able to see how you will get multiple events in the log row.

结论

# 再次感谢您购买这本书！

# 我希望这本书能够帮助你获得坚实的基础。

下一步是在本书中注册我们的免费视频课程，或者使用我们的特别折扣券在 Udemy 上获取完整的视频课程:KD876SOL

到这里: [https://www . udemy . com/solidity-smart-contracts-build-dapps-in-ether eum-区块链/？couponCode=KD878SOL](https://www.udemy.com/solidity-smart-contracts-build-dapps-in-ethereum-blockchain/?couponCode=KD878SOL)

以下是关于整个课程的更多信息:

在过去的几年里，没有比区块链技术更大的刹车了。行业、市场和技术本身的飞速发展导致真正理解区块链的程序员严重短缺。随着区块链协议的出现，智能合约也应运而生——可靠性。

这个课程的目的是给你成为区块链开发者最简单和最好的方法。我们将关注以太坊生态系统中具有可靠性的智能合约开发。

你将在区块链以太坊学会创建你的第一个智能合约，即使你是一个完全的初学者，对编程或可靠性一无所知。

我将向您展示创建您的第一个智能合约的在线 IDE Remix，我们将浏览 Solidity 作为编程语言提供给我们的所有功能。

您还可以设置您的环境，在您的本地机器上开始使用 Solidity 进行编码。我将向您展示我用来设置我的 VSCode 的设置和配置，以及如何在 Windows 上成功安装 Truffle。

之后，我会教你松露框架的基础知识，以及如何让它作为你自己的私人以太坊区块链网络与 Ganache 一起工作。

我们还将通过 Chai 和 Mocha 的单元测试来测试我们的 Solidity smart contracts 行为。如果你是一个认真的开发者，你需要知道你的代码是按照你期望的方式工作的。

当你完成后，你将能够创建你自己的第一个具有可靠性和块菌的分散式应用程序。

虽然其他课程充满了不必要的信息，使他们难以浏览，让你感到困惑，但本课程将带你一步一步地从一个完全的初学者变成以太坊生态系统中可靠和智能合约创建的大师。

在本课程中:

我们将学习以太坊区块链的基本知识。如何制作和保护我们的钱包，以及在创建我们的智能合约时掌握 Metamask 作为我们主要的以太坊钱包。

我们将会学习坚固性语言的基本和高级概念。我们深入了解如何构建您自己的智能合约，并在 Remix 中立即进行测试。

*   我会教你如何使用 Metamask 作为你的以太坊钱包，我会给你安全建议，将保持你的加密资产的安全。
*   我们还将介绍如何使用 Solidity 和 Truffle Framework + Ganache 开发您自己的 DApp 作为您的虚拟区块链，以及设置您的开发环境的正确方法。
*   我们将学习 DApp 开发中的要点，以及智能合约的可靠性和单元测试，这样我们就可以确保我们的代码按照我们预期的方式运行。
*   你会有作业，通过实际的练习帮助你更好地理解材料，而不仅仅是被动的消耗。学完本课程后，你将会爱上可靠性、以太坊生态系统和智能合约的创建。
*   到此: [https://www . udemy . com/solidity-smart-contracts-build-dapps-in-ether eum-区块链/？couponCode=KD878SOL](https://www.udemy.com/solidity-smart-contracts-build-dapps-in-ethereum-blockchain/?couponCode=KD878SOL)
*   最后，如果你喜欢这本书，那么我想请你帮个忙，请你在你购买这本书的网站上留下评论。我将不胜感激，并会有很大帮助。

谢谢你，祝你好运！

Finally, if you enjoyed this book, then I’ d like to ask you for a favor, would you be kind enough to leave a review on the website you bought it from . I t’ d be greatly appreciated and would help a lot.

Thank you and good luck!