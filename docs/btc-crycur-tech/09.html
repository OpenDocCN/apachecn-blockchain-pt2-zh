<html><head/><body>
<html xml:lang="en-US">
  <head>
    
    <link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="../styles/page-template.xpgt"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body id="DB7S0-ea268daff50b4c55a00d858ef79f4a6c" class="calibre">
<p class="chno"><a id="page_190" class="calibre1"/> <b class="calibre2">第八章</b></p>
<p class="chtitle">另类采矿难题</p>
<p class="noindent">挖掘谜题是比特币的核心，因为它们的难度限制了任何一方控制共识过程的能力。因为比特币矿工因他们解决的谜题而获得奖励，我们预计他们会花相当大的努力来寻找任何可用的捷径来更快或更有效地解决这些谜题，以期增加他们的利润。相比之下，为了最大限度地降低成本，矿工可能会被激励跳过任何有利于网络但不会直接有助于更快解决难题的工作。所以谜题的设计对网络中的转向和引导起着重要的作用。</p>
<p class="indent">在这一章中，我们讨论了各种可能的替代谜题设计，假设比特币的谜题可以被修改，甚至从头开始重新设计。一个经典的设计挑战是制作一个抗 ASIC 的拼图，在使用普通计算设备的用户和使用优化定制硬件的用户之间建立公平的竞争环境(参见<a href="part0011.html#sec5_2" class="calibre3">第 5.2 节</a>)。我们还能设计出什么样的拼图来实现呢？我们希望鼓励或阻止哪些其他类型的行为？我们讨论了几个具有各种有趣性质的例子，从减少能源消耗到产生一些对社会有益的副作用，再到阻止矿池的形成。其中一些设计已经被 altcoins 使用，而另一些则是未来可能会使用的研究想法。</p>
<p class="h"><a id="sec8_1" class="calibre3"/> <b class="calibre11"> 8.1。基本拼图要求</b></p>
<p class="noindent">我们先来看看挖掘谜题的一些基本安全要求。如果这个难题不能继续满足保障比特币安全所需的基本要求，那么引入新奇的新功能就没有任何好处。</p>
<p class="indent">有许多可能的要求，其中一些在第 2 章和第 5 章中讨论过。挖掘谜题需要快速验证，因为网络上的每个节点都验证每个谜题解——甚至包括 SPV 客户端在内的不直接参与挖掘的节点。可调整的难度也是必要的，以便当新用户进入网络时，随着贡献的散列功率量的增加，难题的难度可以随着时间而改变。这使得谜题足够困难，以至于对区块链的攻击代价高昂，但谜题解决方案仍以相当稳定的速度被发现(比特币中大约每 10 分钟一次)。</p>
<p class="line"/>
<p class="quote"><i class="calibre9">比特币的挖矿谜题到底是什么？到目前为止，我们称之为“比特币之谜”更准确地说，这是一个<i class="calibre9">部分哈希-前像难题</i>，因为目标是为部分指定的哈希输出找到前像——即低于某个目标值的输出。一些其他罕见的属性也可能起作用，例如找到一个散列至少有<i class="calibre9"> k </i>位被设置为零的块，但是将输出与目标进行比较可能是最简单的。</i></p>
<p class="lineb"/>
<p class="indent">很容易看出比特币的 SHA-256 基于哈希的挖掘难题已经满足了这两个要求。通过调整单个参数(目标<i class="calibre9">和目标</i>)可以任意增加难度。检查答案是琐碎的，只需要一次 SHA-256 计算和一次比较，不管这个谜题有多难解。</p>
<p class="indent">另一个核心要求更微妙:在任何单位时间内赢得谜题答案的机会应该大致与使用的散列值成比例。这意味着，拥有强大硬件的真正大型矿商应该只在成为下一个找到难题解决方案的矿商方面具有比例优势。即使是小矿商也应该有一定比例的成功机会并获得补偿。</p>
<p class="indent">为了说明这一点，考虑一个不满足这一要求的坏拼图。假设一个采矿难题要花整整<i class="calibre9"> n </i>步才能找到答案。例如，我们可能需要计算<i class="calibre9"> n </i>个连续的 SHA-256 散列，而不是找到一个 SHA-256 散列低于某个目标的块。这种检查效率不高，但现在先不要管它。这里更大的问题是，因为找到一个解决方案正好需要 n 步，那么网络中最快的矿工将永远是赢得下一个奖励的人。很快就会清楚哪个矿工正在解决每个难题，而其他矿工根本没有参与的动机。</p>
<p class="indent">同样，一个好的谜题给每个矿工赢得下一个谜题答案的机会，与他们贡献的散列值成比例。想象一下，随机向一块木板投掷飞镖，不同大小的靶子对应不同矿工所持有的矿权。这个要求意味着解决这个难题的几率必须与你已经花费了多少努力来解决它无关(因为大的矿工总是花费更多的努力)。这就是为什么一个好的采矿谜题叫做<i class="calibre9">无进展</i>。</p>
<p class="indent">从数学的角度来看，这意味着一个好的采矿难题必须是一个<i class="calibre9">无记忆过程</i>——任何其他事情都不可避免地会以某种方式奖励矿工过去的进步。因此，任何可行的谜题都必然包含某种试错过程。因此，找到解决方案的时间将不可避免地形成指数分布，正如我们在《T4》第二章中看到的。</p>
<p class="indent">难度可调、快速验证和进度自由是比特币挖矿谜题的三个关键属性。基于 SHA-256 的部分原像发现无疑满足了这三个条件。一些人认为比特币的采矿难题所满足的其他属性也是必不可少的，但我们将在探索其他潜在功能时讨论其他潜在要求。</p>
<p class="h"><a id="sec8_2" class="calibre3"/> <b class="calibre11"> 8.2 .抗 ASIC 拼图</b></p>
<p class="noindent">我们从设计一个抗<i class="calibre9"> ASIC 的</i>拼图的挑战开始，这是迄今为止讨论最广泛、最受追捧的替代性采矿拼图类型。如<a href="part0011.html#AFM60-ea268daff50b4c55a00d858ef79f4a6c" class="calibre3">第五章</a>所述，比特币挖矿最初主要是用普通电脑完成，最终扩展到 GPU 和定制的 FPGA 设备，现在几乎完全由强大的优化 ASIC 芯片完成。这些 ASIC 比通用计算设备效率高得多，以至于用普通计算机(甚至一些早期的 ASIC)挖矿不再值得用电的价格，即使硬件是免费的。</p>
<p class="indent">这种转变意味着参与比特币生态系统的大多数个人(例如，使用比特币进行交易的客户或商家)不再在挖掘过程中扮演任何角色。比特币社区的一些成员认为，一小撮职业矿工控制着开采过程是一种危险的发展。在中本聪关于比特币的原始论文中，使用了“一个 CPU 一票”的短语，这有时被认为是指比特币应该是一个由所有用户拥有的民主系统。</p>
<p class="indent">其他人认为 ASIC 的崛起是不可避免的，对比特币没有坏处，对 ASIC 抵制的渴望只是对“美好旧时光”的怀念。在不表明 ASIC 电阻是否可取的情况下，我们可以深入探讨技术挑战和实现这一目标的一些建议方法。</p>
<p class="h1">ASIC 电阻是什么意思？</p>
<p class="noindent">一般来说，我们希望阻止使用定制硬件进行采矿。严格解释这一点将意味着设计一个难题，现有的通用计算机已经是最便宜和最有效的设备。但这是不可能的。毕竟通用计算机已经有了专用优化。不是所有的产品都有相同的优化，它们会随着时间而变化。例如，在过去十年中，英特尔和 AMD 都增加了对特殊指令的支持(通常称为“增加硬件支持”)，以更有效地计算高级加密标准分组密码。因此，在挖掘方面，一些计算机总是不如其他计算机有效。此外，很难想象设计一个采矿拼图会依赖于像大多数个人电脑都有的扬声器和屏幕这样的功能。因此，去除了这些功能的专用机器可能仍会更便宜、更高效。</p>
<p class="indent">所以实际上我们的目标是一个更适中的目标:想出一个难题，缩小最具成本效益的定制硬件和大多数通用计算机所能做的之间的差距。ASICs 将不可避免地更有效率，但如果我们能把这种优势限制在一个数量级或更少，对个人用户来说，用他们已经拥有的计算机来采矿可能仍然是经济的。</p>
<p class="h1">难以记忆的谜题</p>
<p class="noindent">设计为抗 ASIC 的最广泛使用的谜题被称为<i class="calibre9">内存硬</i>谜题——需要大量内存来计算的谜题，而不是，或者除了大量 CPU 时间之外。一个类似但不同的概念是<i class="calibre9">内存受限</i>谜题，其中访问内存的时间主导了总计算时间。一个难题可能只是记忆困难而没有记忆限制，或记忆限制而没有记忆困难，或两者兼而有之。这是一个微妙但重要的区别，因为即使 CPU 速度是计算的瓶颈<i class="calibre9">时间</i>，并行解决大量此类难题的<i class="calibre9">成本</i>仍可能受内存成本的支配，反之亦然。通常，对于一个计算难题，我们想要一些内存硬的<i class="calibre9">和</i>内存受限的东西，确保需要大量的内存，这是限制因素。</p>
<p class="indent">为什么记忆困难和记忆受限的谜题有助于 ASIC 抵抗？计算现代哈希函数所需的逻辑运算只是 CPU 中运行的一小部分，这意味着对于比特币的难题，ASICs 通过不实现任何不必要的功能而获得了很大的收益。一个相关的因素是，内存性能的差异(以及每单位性能的成本)远低于不同类型处理器的计算速度差异。因此，如果我们可以设计一个难以记忆的难题，需要相对简单的计算，但需要大量的内存，那么解决一个难题的成本将会以较慢的内存成本改善率来改善。</p>
<p class="indent">正如我们所见，SHA-256 绝对不是内存硬，只需要一个很小的 256 位状态，很容易放入 CPU 寄存器中。但是设计一个不易记忆的工作证明拼图并不困难。</p>
<p class="h1">Scrypt</p>
<p class="noindent">最受欢迎的记忆难题叫做<i class="calibre9"> scrypt </i>。这个谜题已经广泛应用于莱特币(第二流行的加密货币)和其他各种比特币替代品。</p>
<p class="indent">Scrypt 是一个内存硬哈希函数，最初是为了以一种难以暴力破解的方式哈希密码而设计的，因此挖掘难题与比特币的部分哈希原像难题相同，只是 scrypt 取代了 SHA-256。</p>
<p class="indent">scrypt 在比特币之前就已经存在，并被用于密码哈希，这让人们对其安全性有了一些信心。密码哈希具有类似的 ASIC 抵抗目标，因为为了安全起见，我们希望拥有定制硬件的攻击者不能比合法用户或服务器计算密码哈希快得多，因为合法用户或服务器可能只有通用计算机。</p>
<div class="cap">
<p class="image"><a id="page_194" class="calibre1"/> <a id="fig8_1" class="calibre1"/> <img src="../images/00085.jpeg" alt="Image" class="calibre13"/></p>
<p class="figcaptionc">图 8.1。Scrypt 伪代码。</p>
</div>
<p class="indent">Scrypt 基本上分两步工作。第一步包括用随机数据填充随机存取存储器(RAM)的大缓冲区。第二步涉及以伪随机顺序读取(和更新)该存储器，要求将整个缓冲器存储在 RAM 中。</p>
<p class="indent"><a href="part0014.html#fig8_1" class="calibre3">图 8.1 </a>显示了 scrypt 伪代码。它演示了核心原则，但是我们忽略了一些细节:实际上，scrypt 处理的数据块稍微大一些，填充缓冲区的算法稍微复杂一些。</p>
<p class="indent">要了解 scrypt 为什么很难存储，想象一下在不使用缓冲区<i class="calibre9"> V </i>的情况下尝试计算相同的值(参见<a href="part0014.html#fig8_1" class="calibre3">图 8.1 </a>)。这当然是可能的——但是，在第 9 行，我们需要动态地重新计算值<i class="calibre9"> V </i> [ <i class="calibre9"> j </i> ]，这需要计算 SHA-256 的<i class="calibre9"> j </i>次迭代。因为在循环的每次迭代期间<i class="calibre9"> j </i>的值将在 0 和<i class="calibre9">N</i>–1 之间随机选择，这将需要大约<i class="calibre9"> N </i> /2 次 SHA-256 计算。这意味着计算整个函数现在将花费<i class="calibre9">N</i><i class="calibre9">N</i>/2 =<i class="calibre9">N</i><sup class="calibre14">2</sup>/2 SHA-256 计算，而不是仅仅 2 <i class="calibre9"> N </i>如果使用缓冲区的话！因此，内存的使用将 scrypt 从一个<i class="calibre9"> O </i> ( <i class="calibre9"> N </i>)函数转换为一个<i class="calibre9">O</i>(<i class="calibre9">N</i>T51】2 函数。选择足够大的<i class="calibre9"> N </i>应该很简单，这样<i class="calibre9">O</i>(<i class="calibre9">N</i>T59】2)就足够慢，使得使用内存成为更快的选择。</p>
<p class="h1">时间记忆权衡</p>
<p class="noindent">虽然如果没有大内存缓冲区的帮助，计算 scrypt 的速度会慢得多，但仍然可以使用较少的内存，代价是计算量稍微多一点。假设我们使用大小为<i class="calibre9"> N </i> /2 的缓冲区(而不是大小为<i class="calibre9"> N </i>)。现在，如果<i class="calibre9"> j </i>是偶数，我们可以只存储值<i class="calibre9"> V </i> [ <i class="calibre9"> j </i>，丢弃值<i class="calibre9"> j </i>是奇数。在第二个循环中，大约有一半的时间会选择一个奇数值<i class="calibre9"> j </i>，但这现在很容易计算——我们简单地计算 SHA-256(<i class="calibre9">V</i>[<i class="calibre9">j</i>–1])，因为在我们的缓冲区中<i class="calibre9">V</i>[<i class="calibre9">j</i>–1】将是<a id="page_195" class="calibre3"/>。由于这种情况大约有一半时间会发生，因此会增加<i class="calibre9"> N </i> /2 次额外的 SHA-256 计算。</p>
<p class="indent">因此，将我们的内存需求减半只会增加四分之一的 SHA-256 计算次数(从 2 <i class="calibre9"> N </i>到 5 <i class="calibre9"> N </i> /2)。一般来说，我们只能存储缓冲区<i class="calibre9"> V </i>的每<i class="calibre9"> k </i>行，使用<i class="calibre9"> N </i> / <i class="calibre9"> k </i>内存和计算(<i class="calibre9"> k </i> + 3) <i class="calibre9"> N </i> /2 次 SHA-256 迭代。在极限中，如果我们设置<i class="calibre9"> k </i> = <i class="calibre9"> N </i>，我们回到我们之前的计算，其中运行时间变成<i class="calibre9">O</i>(<i class="calibre9">N</i>T49】2)。这些数字并不完全适用于 scrypt 本身，但渐近估计适用。</p>
<p class="indent">还有一些替代设计可以降低用时间来交换内存的能力。例如，如果缓冲区在第二个循环中不断更新，它会使时间-内存权衡变得不那么有效，因为更新必须被存储。</p>
<p class="h1">验证成本</p>
<p class="noindent">scrypt 的另一个限制是它需要和计算一样多的内存来验证。为了使记忆硬度有意义，<i class="calibre9"> N </i>需要相当大。这意味着 scrypt 的一次计算比 SHA-256 的一次迭代要昂贵几个数量级，这是检查比特币更简单的挖掘难题所需要的。</p>
<p class="indent">这种开销具有一些负面的结果，因为网络中的每个客户端都必须重复这种计算，以检查所要求的新块是否有效。这可能会减慢新块的传播和接受，并增加分叉的风险。这也意味着每个客户端(甚至是轻量级 SPV 客户端)都必须有足够的内存来高效地计算函数。因此，加密货币中可用于 scrypt 的内存量<i class="calibre9"> N </i>多少受到实际问题的限制。</p>
<p class="indent">直到最近，人们还不知道是否有可能设计出一个难以计算但可以快速(且容易记忆)验证的采矿难题。该属性对密码哈希没有用，在加密货币中使用之前，密码哈希是内存硬函数的主要用例。</p>
<p class="indent">2014 年，约翰·特罗姆普提出了一个新的谜题<i class="calibre9">布谷鸟周期</i>。布谷鸟循环是基于从布谷鸟哈希表生成的图中寻找循环的难度，布谷鸟哈希表本身是 2001 年才提出的数据结构。没有任何已知的方法可以在不建立大型哈希表的情况下计算它，但是可以简单地通过检查是否发现了(相对较小的)循环来检查它。</p>
<p class="indent">这一难题可能会使记忆困难或记忆受限的工作证明在比特币共识中的使用更加实际。不幸的是，没有数学证据证明这个函数在不使用内存的情况下无法有效计算。通常，新的加密算法看起来是安全的，但社区并不相信，直到它们已经存在了许多年而没有发现攻击。由于这个原因，以及最近的发现，截至 2015 年，布谷鸟循环尚未被任何加密货币使用。</p>
<p class="h1">实践中的秘密</p>
<p class="noindent">Scrypt 已经在许多加密货币中使用，包括几个流行的加密货币，如莱特币。结果有些喜忧参半。Scrypt ASICs 已经可以用于 Litecoin 选择的参数(并被许多其他 altcoins 复制)。令人惊讶的是，与通用计算机相比，这些专用集成电路的性能改进已经等于或大于 SHA-256！因此，scrypt 最终肯定不是 ASIC 抗性的，至少像莱特币所使用的那样。莱特币的开发者最初声称 ASIC 的抵抗力是比特币的一个关键优势，但后来承认情况不再如此。</p>
<p class="indent">ASIC 电阻的缺乏可能是 Litecoin 使用的<i class="calibre9"> N </i>(内存使用参数)值相对较低的结果，仅需要 128 千字节来计算(如果使用时间-内存权衡，则更少，这通常在 GPU 上进行，以使整个缓冲区适合更快的缓存)。如此低的 T2 N T3 值使得设计轻量级采矿专用集成电路变得相对容易，而不需要像通用计算机那样使用复杂的内存访问总线来访问千兆字节的 RAM。Litecoin 开发人员没有选择一个高得多的值(这会使 ASICs 更难设计)，因为他们认为验证成本不切实际。</p>
<p class="h1">ASIC 电阻的其他方法</p>
<p class="noindent">回想一下，我们最初的目标只是让构建具有显著性能加速的 ASICs 变得更加困难。记忆硬度只是实现这一目标的一种方法。</p>
<p class="indent">不幸的是，其他方法不是很科学，也没有像硬记忆函数那样被严格设计或攻击。最著名的是 X11，它是由一个名为“Darkcoin”(后来改名为 DASH)的 altcoin 引入的 11 个不同散列函数的简单组合，后来被其他几个人使用。X11 的目标是使高效 ASIC 的设计变得更加复杂，因为所有 11 种功能都必须在硬件中实现。但这对于硬件设计师来说，无非是一种不便。如果为 X11 构建 ASIC，它肯定会使 CPU 和 GPU 挖掘过时。</p>
<p class="indent">另一个已经被提出，但还没有真正实现的方法，是有一个移动目标的挖掘难题。也就是说，挖掘难题本身会发生变化，就像比特币的难度会周期性变化一样。理想情况下，拼图会以这样一种方式改变，即先前拼图的优化挖掘硬件对新拼图不再有用。现在还不清楚到底如何经常改变谜题来获得安全需求。如果由替代硬币的开发者做出决定，这可能是一个不可接受的集权来源。例如，开发人员可能会选择一个他们已经开发了硬件(或者只是一个优化的 FPGA 实现)的新难题，这给了他们早期的优势。</p>
<div class="box">
<p class="quotebb"><b class="calibre11">X11 的哈希函数从何而来？</b></p>
<p class="quoteb">从 2007 年到 2012 年，美国国家标准研究所举办了一场竞赛，以选择一个新的哈希函数家族作为 SHA-3 标准。这产生了大量的散列函数，它们作为候选函数提交，并附有完整的设计文档和源代码。虽然这些候选人中有许多在比赛中被证明不是密码安全的，但有 24 人幸存下来，没有受到任何已知的密码攻击。X11 选择了其中的 11 个，包括最终的比赛冠军 Keccak。</p>
</div>
<p class="indent">也许谜题序列可以自动生成，但这似乎也很困难。一种想法可能是采用一大组散列函数(例如，24 个未被破坏的 SHA-3 候选函数)并使用每个函数 6 个月到 1 年，这对于硬件开发来说是太短的时间。当然，如果预先知道时间表，那么硬件可以简单地设计成正好在引入所使用的每一个功能时发货。</p>
<p class="h1">ASIC 蜜月</p>
<p class="noindent">到目前为止，X11 缺少 ASICs，尽管它们显然是可以构建的，这展示了一个潜在的有用模式。因为使用 X11 的替代币没有特别高的市场份额，所以还没有足够大的市场让任何人为 X11 构建 ASICs。一般来说，设计 ASICs 的前期成本(时间和金钱)很高，而每生产一个硬件单位的边际成本相对较低。因此，对于新的和未经证实的加密货币，如果在新的硬件可供开采之前货币可能失败，则不值得投资建立硬件。即使存在一个明确的市场，在硬件设备准备就绪之前也有一段时间的延迟。第一批比特币专用集成电路从最初设计到出货花了一年多时间，这对硬件行业来说被认为是闪电般的速度。</p>
<p class="indent">因此，任何具有新挖掘难题的新 altcoin 都可能会经历一个<i class="calibre9"> ASIC 蜜月期</i>，在此期间，GPU 和 FGPA 挖掘(甚至可能是 CPU 挖掘)将会盈利。也许不可能永远阻止 ASICs 的潮流，但在自举的同时吸引个人参与采矿(并赚取一些新货币单位)或许有一些价值。</p>
<p class="h1">反对 ASIC 电阻的论点</p>
<p class="noindent">我们已经看到，从长远来看，实现 ASIC 电阻可能是不可能的。但也有观点认为，从相对成熟的 SHA-256 矿业谜题转向一个在密码学上可能较弱的新谜题是有风险的。此外，SHA-256 矿业专用集成电路的设计已经接近硬件效率的现代极限，这意味着指数增长期可能已经结束，因此 SHA-256 矿业将为网络提供最大的稳定性。</p>
<p class="indent">最后，可以说，即使从短期来看，ASIC 电阻也不是一个好特性。回想一下第 3 章中的内容，即使对于 51%的矿工来说，许多类型的攻击对她来说都是不合理的，因为这可能会导致汇率崩溃，并大幅降低<a id="page_198" class="calibre3"/>矿工在硬件上的投资价值，因为她从采矿中获得的比特币将会贬值很多。</p>
<p class="indent">有了高度抗 ASIC 的谜题，这个安全论点可能会土崩瓦解。例如，攻击者可能能够临时租用大量通用计算能力(从服务中，如亚马逊的 EC2)，使用它进行攻击，然后不会遭受任何经济后果，因为她在攻击后不再需要租用能力。相比之下，对于 ASIC 友好的谜题，这样的攻击者本质上需要控制大量 ASIC，这些 ASIC 只对挖掘加密货币有用。这样的攻击者将最大限度地投资于货币未来的成功。按照这一论点的逻辑结论，为了最大限度地提高安全性，也许挖掘谜题不仅应该能够建立有效的挖掘 ASIC，而且应该设计成这些 ASIC 在加密货币之外完全无用！</p>
<p class="h"><a id="sec8_3" class="calibre3"/> <b class="calibre11"> 8.3。有用工作的证明</b></p>
<p class="noindent">在第 5 章的<a href="part0011.html#AFM60-ea268daff50b4c55a00d858ef79f4a6c" class="calibre3">中，我们讨论了比特币开采所消耗的能源(有些人会说是浪费的能源)，被经济学家称为<i class="calibre9">负外部性</i>，是一个潜在的问题。我们估计比特币开采会消耗数百兆瓦的电力。一个显而易见的问题是，是否存在这样一个难题，为解决这个难题所做的工作为社会提供了一些其他的好处。这将相当于某种形式的回收，并有助于增加对加密货币的政治支持。当然，这个难题仍然需要满足几个基本要求，才能适用于共识协议。</a></p>
<p class="h1">以前的分布式计算项目</p>
<p class="noindent">善用闲置电脑(或“备用周期”)的想法比比特币要古老得多。<a href="part0014.html#tab8_1" class="calibre3">表 8.1 </a>列出了一些最受欢迎的志愿者计算项目。所有这些项目都有一个特性，可能使它们适合用作计算难题:它们涉及某种“大海捞针”问题，有很大的潜在解决方案空间，搜索空间的一小部分可以相对快速地并行检查。例如，在 SETI@home 中，志愿者被给予一小部分观察到的无线电信号来扫描潜在的模式，而在<a href="http://distributed.net" class="calibre3">distributed.net</a>中，志愿者被给予小范围的潜在密钥来测试。</p>
<p class="indent">志愿者计算项目通过将解决方案空间的一小部分分配给个人进行检查取得了成功。事实上，这种范式是如此普遍，以至于开发了一个名为“BOINC”(伯克利网络计算开放基础设施)的特定库，以便于将小块工作分配给个人完成。</p>
<p class="indent">在这些应用中，志愿者的动机主要是对潜在问题的兴趣，尽管这些项目也经常使用排行榜让志愿者炫耀他们贡献了多少计算。这导致一些人试图通过报告没有实际完成的工作来欺骗排行榜，要求一些项目采取发送少量多余工作的方式来检测作弊。当然，对于加密货币的使用，动机主要是货币，我们可以预期参与者会试图在技术上尽可能多地作弊。</p>
<p class="tcaption"><a id="tab8_1" class="calibre3"/> <b class="calibre11">表 8.1。热门志愿者计算项目</b></p>
<p class="image"><img src="../images/00086.jpeg" alt="image" class="calibre13"/></p>
<p class="h1">将有用的谜题应用于工作证明的挑战</p>
<p class="noindent">鉴于这些项目的成功，我们可能会尝试简单地直接使用这些问题。例如，在 SETI@home 的案例中，志愿者被给予无线电观测片段，他们测试统计异常，我们可能会决定比某个阈值更少的统计异常被视为谜题的“获胜”解决方案，并允许任何找到一个的矿工创建一个区块。</p>
<p class="indent">这个想法有几个问题。首先，请注意，潜在的解决方案不一定都是成功的解决方案。参与者可能会意识到某些部分比其他部分更有可能产生异常。在一个集中的项目中，参与者被分配工作，所以所有的部分最终都可以被分析(也许更有前途的部分被给予优先权)。然而，对于采矿，任何矿工都可以尝试任何细分市场，这意味着矿工可能会蜂拥而至，首先尝试最有可能的细分市场。这可能意味着这个难题并不是完全没有进展，如果更快的矿工知道他们可以先测试最有希望的部分。与比特币的难题相比，任何随机数都有可能产生有效的区块，因此所有矿工都有动力选择随机随机数来尝试。这里的问题展示了我们之前认为理所当然的比特币难题的一个关键属性:一个<i class="calibre9">等概率解空间</i>。</p>
<p class="indent">接下来考虑 SETI@home 基于射电望远镜拍摄的观测数据有固定数量的数据要分析的问题。随着采矿力量的增加，可能不再有原始数据可供分析。再来比较一下比特币，在比特币中可以创造出无限数量的 SHA-256 谜题。这揭示了另一个重要的要求:需要一个<i class="calibre9">用之不竭的拼图空间</i>。</p>
<p class="indent">最后，考虑 SETI@home 使用一组可信的集中管理员来管理新的无线电数据，并确定参与者应该寻找什么。<a id="page_200" class="calibre3"/>再一次，因为我们正在使用我们的难题来建立一个共识算法，我们不能假设一个集中的政党来管理这个难题。因此，我们需要一个可以用算法生成的谜题。</p>
<p class="h1">哪些志愿者计算项目可能适合作为拼图？</p>
<p class="noindent">回到<a href="part0014.html#tab8_1" class="calibre3">表 8.1 </a>，我们可以看到 SETI@home 和 Folding@home 显然不适用于分散式共识协议。两者都可能缺少我们现在添加到列表中的所有三个属性。由<a href="http://distributed.net" class="calibre3">distributed.net</a>承担的密码暴力破解问题可能会起作用，尽管它们通常是为了应对特定的解密挑战而选择的，这些挑战是由寻求评估某些算法安全性的公司设定的。这些是无法通过算法生成的。我们可以通过算法生成解密挑战，通过暴力破解，但在某种意义上，这正是 SHA-256 部分原像发现已经做的，它没有任何有益的功能。</p>
<p class="indent">这使得伟大的互联网梅森素数搜索，这证明是接近可行的。挑战可以通过算法生成(找到一个比上一个大的素数)，谜题空间无穷无尽。事实上，它是无穷的，因为已经证明有无穷多个素数(尤其是无穷多个梅森素数)。</p>
<p class="indent">唯一真正的缺点是，大型梅森素数需要很长时间才能找到，而且非常罕见。事实上，伟大的互联网梅森素数搜索在过去的 18 年里只找到了 14 个梅森素数！很明显，每年向区块链添加少于一个数据块是行不通的。这个具体问题似乎缺少我们在第 8.1 节中提到的可调节难度属性。然而，事实证明，类似的寻找素数的问题似乎可以作为一个计算难题。</p>
<p class="h1">原始硬币</p>
<p class="noindent">截至 2015 年，在实践中部署的唯一有用工作证明系统是 Primecoin。素数币的挑战是找到素数的坎宁安链。坎宁安链是一个由<i class="calibre9"> k </i>质数<i class="calibre9"> p </i> <sub class="calibre16"> 1 </sub>，<i class="calibre9"> p </i> <sub class="calibre16"> 2 </sub>，…，<i class="calibre9"> p <sub class="calibre16"> k </sub> </i>组成的序列，使得链中的每个数都为<i class="calibre9">p<sub class="calibre16">I</sub></i>= 2<i class="calibre9">p</i><sub class="calibre16">I–1</sub>+1。也就是你取一个质数，加倍再加一得到另一个质数，继续下去直到得到一个合数。序列 2，5，11，23，47 是长度为 5 的坎宁安链。这个数字链中潜在的第六个数字 95 不是质数(95 = 5 ^ 19)。已知最长的坎宁安链长度为 19(从 79，910，197，721，667，870，187，016，101 开始)。人们猜测并普遍相信，但没有证明，对于任何一个<i class="calibre9"> k </i>存在长度为<i class="calibre9"> k </i>的坎宁安链。</p>
<p class="indent">现在，为了把这变成一个计算难题，我们需要三个参数<i class="calibre9"> m，n </i>和<i class="calibre9"> k </i>，我们将马上解释。对于给定的挑战<i class="calibre9"> x </i>(前一个块的散列)，我们取<i class="calibre9"> x </i>的前<i class="calibre9"> m </i>位，并认为<a id="page_201" class="calibre3"/>中长度为<i class="calibre9"> k </i>或更长的任何链是一个<i class="calibre9"> n </i>位素数并且具有与<i class="calibre9"> x </i>相同的<i class="calibre9"> m </i>前导位是一个有效解。注意，我们可以调整<i class="calibre9"> n </i>和<i class="calibre9"> k </i>来增加拼图的难度。增加<i class="calibre9"> k </i>(所需的链长)会使问题成倍增加，而增加<i class="calibre9"> n </i>(起始素数的大小)会使问题多项式增加。这提供了难度的微调。<i class="calibre9"> m </i>的值只需要足够大，使得在看到前一个块的值之前试图预先计算解决方案是不可行的。</p>
<p class="indent">我们讨论的所有其他属性似乎都已提供:解决方案可以相对快速地验证，问题是无进展的，问题空间是无限的(假设一些关于素数分布的经过充分研究的数学猜想是正确的)，谜题可以通过算法生成。事实上，这个谜题已经在 Primecoin 中使用了将近 2 年，并且已经在 Cunningham 链中为 k 的许多值产生了最大的已知素数。Primecoin 此后扩展到在其工作证明中包括其他类似类型的 prime 链，包括“第二种”坎宁安链，其中<i class="calibre9">p<sub class="calibre16">I</sub></i>= 2<i class="calibre9">p</i><sub class="calibre16"><i class="calibre15">I</i>–1</sub>–1。</p>
<p class="indent">这个例子提供了强有力的证据，证明在某些有限的情况下证明有用的工作是可行的。当然，寻找大型坎宁安链的有用程度是有争议的。它们在未来可能会有一些应用目的，它们无疑是对我们集体数学知识的一个小小贡献。然而，目前它们还没有已知的实际应用。</p>
<p class="h1">永久硬币和存储证明</p>
<p class="noindent">证明有用功的另一种方法是<i class="calibre9">存储证明</i>(有时也称为<i class="calibre9">可检索性证明</i>)。如果我们可以设计一个需要存储大量数据来计算的谜题，而不是需要一个单独的计算谜题，会怎么样？如果这些数据是有用的，那么矿工在采矿硬件上的投资将有效地促进广泛分布和复制的档案存储系统。</p>
<p class="indent">考虑<i class="calibre9"> Permacoin </i>，第一个用于共识的存储证明提案。我们从一个大文件<i class="calibre9"> F </i>开始。现在，假设每个人都同意<i class="calibre9"> F </i>的值，并且文件不会改变。例如，当加密货币推出时，可信的交易商可能会选择<i class="calibre9"> F </i>，就像任何新货币都需要就一个创世区块达成一致才能运行一样。这个文件最好具有公共价值。例如，从大型强子对撞机上收集的实验数据已经有几百 Pb 了。为这些数据提供免费备份会非常有用。</p>
<p class="indent">当然，由于<i class="calibre9"> F </i>是一个巨大的文件，大多数参与者不可能存储整个文件。但是我们已经知道如何使用加密散列函数来确保每个人都同意<i class="calibre9"> F </i>而不知道文件的全部内容。最简单的方法是每个人都同意<i class="calibre9"> H </i> ( <i class="calibre9"> F </i>)，但更好的方法是用一棵大的 Merkle 树来表示<i class="calibre9"> F </i>，并让所有参与者都同意根的值。现在，每个人都同意 F 的值，证明 f <i class="calibre9">的任何部分都是正确的是有效的。</i></p>
<p class="indent">在永久硬币中，每个矿工<i class="calibre9"> M </i>存储一个随机子集<i class="calibre9">f<sub class="calibre16">m</sub>t17】⊆<i class="calibre9">f</i>。为了实现这一点，当<a id="page_202" class="calibre3"/>矿工生成一个他将用来接收资金的公钥<i class="calibre9">K<sub class="calibre16">M</sub>T24】时，他散列他的公钥以生成一组伪随机块<i class="calibre9">F<sub class="calibre16">M</sub>T28】，他必须存储这些块以便能够挖掘。这个子集将是某个固定数量的块<i class="calibre9">k<sub class="calibre16">1</sub>T32】。在这里，我们必须假设矿工在开始采矿时有某种方法来获取这些块——也许是从规范的来源下载它们(<a href="part0014.html#fig8_2" class="calibre3">图 8.2 </a>)。</i></i></i></i></p>
<div class="cap">
<p class="image"><a id="fig8_2" class="calibre1"/> <img src="../images/00087.jpeg" alt="Image" class="calibre13"/></p>
<p class="figcaption">图 8.2。在 Permacoin 中选择文件中的随机块。在这个例子中，<i class="calibre9"> k </i> <sub class="calibre16"> 1 </sub> = 6，<i class="calibre9"> k </i> <sub class="calibre16"> 2 </sub> = 2。在实际实现中，这些参数会大得多。</p>
</div>
<p class="indent">一旦矿工在本地存储了<i class="calibre9">F<sub class="calibre16">M</sub>T48】，这个谜题就和传统的 SHA-256 采矿非常相似。给定一个先前的块散列<i class="calibre9"> x </i>，挖掘器选择一个随机随机数值<i class="calibre9"> n </i>并对此进行散列以生成一个伪随机子集<i class="calibre9"> F <sub class="calibre16"> M，n</sub>t56】⊆<i class="calibre9">f<sub class="calibre16">m</sub>t60】，由<i class="calibre9">k</i>t63】2&lt;t65】k</i>t67】1 组成注意，这个子集既取决于矿工选择的随机数，也取决于他的公钥。最后，挖掘器计算<i class="calibre9"> n </i>和<i class="calibre9">F<sub class="calibre16">k</sub>T74】中的块的阿沙-256 哈希。如果这个散列值低于目标难度，他就找到了有效的解决方案。</i></i></i></p>
<p class="indent">验证解决方案需要以下步骤:</p>
<p class="bullt">验证<i class="calibre9"> F <sub class="calibre16"> M，n</sub>T78】是从矿工的公钥<i class="calibre9">K<sub class="calibre16">M</sub>T82】和随机数<i class="calibre9"> n </i>中正确生成的。</i></i></p>
<p class="bull">通过验证其在 Merkle 树中到<i class="calibre9"> F </i>的全局一致根的路径，验证<i class="calibre9"> F <sub class="calibre16"> M，n</sub>T88】的每个块是否正确。</i></p>
<p class="bull">确认<i class="calibre9"> H </i> ( <i class="calibre9"> F <sub class="calibre16"> M，n </sub> </i> || <i class="calibre9"> n </i>)小于目标难度。</p>
<p class="indentt">很容易理解为什么解谜需要挖掘器将所有的<i class="calibre9"> F <sub class="calibre16"> M，n</sub>T102】存储在本地。对于每个 nonce，挖掘器需要测试随机的块子集<i class="calibre9"> F <sub class="calibre16"> M，n </sub> </i>的散列，这对于通过网络从远程存储器获取数据来说会非常慢。</i></p>
<p class="indent">与 scrypt 的情况不同，只要<i class="calibre9">k</i>t 109】2 足够大，就没有合理的时间-内存权衡。如果一个矿工只在本地存储一半的<i class="calibre9"> F <sub class="calibre16"> M </sub> </i>和<i class="calibre9"> k </i> <sub class="calibre16"> 2 </sub> = 20，他们将不得不尝试一百万个随机数，然后才能找到一个不需要通过网络获取任何块的随机数。因此，以一个常数因子减少它们的存储负担会以指数方式增加它们的计算负担。当然，将<i class="calibre9"> k </i> <sub class="calibre16"> 2 </sub>设置得太大不会非常有效，因为在任何有效的解决方案中，都必须传输和验证<i class="calibre9">k</i><sub class="calibre16">2</sub>Merkle 树路径。</p>
<p class="indent">设置<i class="calibre9"> k </i> <sub class="calibre16"> 1 </sub>也是有取舍的。越小的<i class="calibre9"> k </i> <sub class="calibre16"> 1 </sub>就需要越少的存储来发挥矿工的功能，因此采矿更加民主。不过，这也意味着<a id="page_203" class="calibre3"/>较大的矿商没有动力储存超过<i class="calibre9">k</i>T11】1 块的<i class="calibre9"> F </i>块，即使他们有能力储存更多。</p>
<p class="indent">像往常一样，这个例子是对完整的 Permacoin 提案的一个轻微简化，但它足以理解关键的设计组件。当然，最大的实际挑战是找到一个合适的大文件，它是重要的、公共的，并且需要额外的复制。如果文件<i class="calibre9"> F </i>随着时间的推移而改变，以及随着时间的推移调整挖掘难度，也存在显著的复杂性。</p>
<p class="h1">长期挑战和经济学</p>
<p class="noindent">总结这一节，证明有用的工作是一个自然的目标，但实现它是相当具有挑战性的，因为一个好的共识协议的计算难题还有其他要求。尽管已知至少有两个技术上可行的例子，Primecoin 和 Permacoin，但它们都有一些技术上的缺点(主要是对声称的解决方案的验证时间较长)。此外，与我们在比特币开采中看到的努力规模相比，两者都提供了相当小的公共利益，耗费了价值数百万美元的资本和数兆瓦的电力。</p>
<p class="indent">有一个有趣的经济论点，即任何有用工作证明的好处应该是纯粹的公共利益。在经济学中，公共物品是不可排除的，意味着没有人可以被阻止使用它，也是非竞争性的，意味着其他人使用该物品不会影响其价值。典型的例子是灯塔。</p>
<p class="indent">我们在这里讨论的一些例子，如蛋白质折叠，可能不是纯粹的公共产品，因为一些公司(如大型制药公司)可能比其他公司更多地受益于蛋白质折叠知识的增加。从本质上讲，采矿对这些团体来说更便宜，因为他们从公共利益中获得的好处比其他人更多。</p>
<p class="h"><a id="sec8_4" class="calibre3"/>8.4<b class="calibre11">。不可外包的谜题</b></p>
<p class="noindent">让我们转向另一个替代采矿难题的潜在设计目标:防止采矿池的形成。正如第五章和其他地方所讨论的，大多数比特币矿工是作为资金池的一部分而不是独立开采的。这导致了几个大的池，共同代表了大部分的采矿力量。由于每个池都由一个中央池管理员运营，一些利益相关者认为这是一个危险的趋势，背离了比特币去中心化的核心设计原则，并可能危及其安全性。</p>
<p class="indent">具有多数份额的挖掘池是一个明显的问题，但是任何大型的集中管理的池都可能实施非默认的挖掘策略并攻击网络。这种池也是黑客试图妥协的诱人目标，导致黑客控制了大量的采矿权。资金池运营商可能会串通起来审查交易或收取高额交易费。至少，让大多数挖掘者在池中也意味着大多数挖掘者没有运行完全验证的节点。</p>
<p class="indent">有趣的是，这些担忧在投票领域也有相似之处。在美国和许多其他国家，个人出售选票是非法的。可以说，参与由他人控制的资金池类似于在比特币共识协议中出售你的选票。</p>
<p class="h1">池的技术要求</p>
<p class="noindent">回想一下，矿池似乎是一种新兴现象。没有证据表明，在比特币最初设计的时候，Satoshi 正在考虑采矿池。几年后，在许多互不了解或互不信任的个人之间建立高效的人才库才变得不明显。</p>
<p class="indent">正如我们在第 5 章中看到的，挖掘池通常通过指定一个具有众所周知的公钥的池操作者来工作。每个参与的矿工照常采矿，但将股份送给联营公司。这些共享是“接近失误”，或部分解决方案，在较低的难度水平下是有效的解决方案。这向池操作员显示了矿工正在执行的工作量。当资金池参与者之一找到一个有效的区块时，资金池运营商然后根据他们提交的份额数量在资金池参与者之间分配奖励。正如在<a href="part0011.html#AFM60-ea268daff50b4c55a00d858ef79f4a6c" class="calibre3">第 5 章</a>中所讨论的，有许多分配收入的公式，但是所有的矿池都遵循这个基本结构。</p>
<p class="indent">因此，比特币池的存在至少依赖于比特币的两个技术属性。首先，矿商很容易通过提交股份来证明(从概率上)他们做了多少工作。通过为份额选择一个足够低的阈值，采矿者可以很容易地证明他们以任意的精度完成了多少工作，而不管找到一个有效区块的实际难度。挖掘谜题的这个方面似乎很难改变，因为我们需要一个可以以任意难度创建的谜题。</p>
<p class="indent">第二，池成员可以很容易地向池运营商证明，他们遵守规则，并努力找到有效的区块，这将奖励池作为一个整体。矿工提交的份额构成了这样一个证明，因为池的公钥被提交给块的 Merkle 事务树中包含的 coinbase 事务。一旦矿工发现一个区块，甚至一个份额，他们就不能改变哪个公钥是新铸造硬币的接收者。</p>
<p class="h1">分组丢弃攻击</p>
<p class="noindent">这种实现采矿池的方案有一个缺点:没有任何东西可以保证参与的采矿者在发现有效区块时会将它们提交给池管理器。假设一个池成员对一个大型矿池感到不安。她可以像往常一样通过开采和提交份额来参与该池，但是如果她实际上找到了将奖励该池的有效区块，她可以简单地丢弃它，并且不将它告诉池操作者。</p>
<p class="indent">这种攻击降低了池的整体挖掘能力，因为攻击者的任何工作都无助于找到有效的块。然而，攻击者仍然会得到回报，因为她似乎提交了有效的份额，只是没有找到任何有效的块。如果挖矿池被设计成收益中性的(即所有挖矿奖励都重新分配回参与者)，那么这种攻击就可能导致挖矿池亏本运行。</p>
<div class="box">
<p class="quotebb"><a id="page_205" class="calibre3"/> <b class="calibre11">池间弃块攻击</b></p>
<p class="quoteb">多年来，人们一直认为参与者丢弃代表池中找到的有效块是无利可图的。事实证明，如果一个矿池利用这种策略攻击另一个矿池，这种策略是有利可图的。这是多次被伪提出的，并在 2015 年由 Ittay Eyal 在一篇论文中首次进行了彻底的分析。</p>
<p class="quoteb">考虑一个简单的例子:假设两个开采池 A 和 B，每个都有总开采能力的 50%。现在假设 B 使用其一半的开采能力(总产能的 25 %)作为池 A 中的成员进行开采，但是丢弃所有找到的区块。我们可以在一个简化的模型中显示，B 公司现在将获得总回报的 5/9，比正常采矿所获得的 50%要多。在这个简单的例子中，将一半的采矿力量用于攻击可以证明是池 b 的最优策略。</p>
<p class="quoteb">多池的情况变得更加复杂。截至 2015 年，在实践中没有观察到大规模的块丢弃。但从长远来看，像这样的攻击仍有可能让大型矿池的生存能力受到质疑。</p>
</div>
<p class="indent">这种攻击有时被称为<i class="calibre9">义务警员</i>或<i class="calibre9">破坏</i>攻击，并被认为是一种故意破坏的形式，因为这种攻击似乎对攻击者和池都代价高昂。攻击者会损失金钱，因为丢弃的每一个方块都会导致一定比例的方块奖励返还给攻击者。当然，攻击者仍然会因为找到其他谜题答案而获得奖励。</p>
<p class="indent">似乎一个理性的攻击者不会采用这种策略，因为她会损失金钱而得不到任何有形的东西。事实证明(相当令人惊讶),有些情况下这种策略是有利可图的。我们想设计一个全新的采矿难题公式，确保这一战略总是有利可图。</p>
<p class="h1">奖励破坏</p>
<p class="noindent">我们的设计目标是鼓励矿工在池中采矿，但不向池管理者提交有效区块。目前，只有池管理者可以收集采矿奖励，因为管理者要求所有参与者在他们正在开采的区块的 coinbase 事务中包括特定的公钥。可以很容易地在提交的部分解决方案中检查适当的包含。池管理者是唯一知道私钥的一方，因此可以确定新铸造的硬币的去向。</p>
<p class="indent">但是，如果我们要求所有参与者都知道私钥(因此可以在挖掘一个区块后重定向资金)会怎么样？).要做到这一点，我们需要一个难题，其中每个解决方案尝试都需要知道 coinbase 事务中的私钥。我们可以将难题从“找到一个散列低于某个目标的块”改为“找到一个块，对于该块，签名的散列低于某个 T2 目标”该签名必须使用 coinbase 事务中使用的相同公钥来计算。</p>
<p class="indent">这样一个难题让潜在的泳池运营商面临两个站不住脚的选择。他们可能将私钥分发给所有池参与者，在这种情况下，任何参与者都可以窃取所有资金。或者，他们可以代表池参与者执行签名。然而，计算一个签名比计算一个散列要昂贵得多，所以在这种情况下，池管理器将完成大部分繁重的工作。对于泳池管理员来说，最好只是做一名单枪匹马的矿工。</p>
<p class="h1">非外包采矿的利与弊</p>
<p class="noindent">由于这个难题不能有效地外包给不可信的参与者，所以与不可信的参与者形成一个挖掘池更具挑战性，如果不是完全不可能的话。它有效地阻止了所有池，甚至阻止了在没有池管理器的情况下创建分散池的努力，例如 P2Pool。</p>
<p class="indent">有一种观点认为，部署这样一个难题可能会反常地导致更多的集中化，而不是更少，因为它会阻止小矿工参与，因为他们将面临很大的差异。这将只留下大型采矿作业。目前，虽然联营公司名义上可能控制着大量的采矿权力，但还不清楚它们能否利用这种权力发起攻击，而不会让许多成员叛逃。这仍然是一个悬而未决的问题，即大型矿池的风险更大，还是将采矿限制在足以承受高方差的运营商范围内。</p>
<p class="indent">圣杯将是设计一个共识协议，本质上是低差异的，通过奖励矿工少量的低难度谜题。那么矿工就不需要组成矿池，然而小矿工仍然可以参与。简单地减少区块之间的平均时间是行不通的，需要减少 1000 倍或更多，才能使最终的方差相当于今天的大型矿池的方差。但是块之间的延迟会少于一秒钟，并且旧块的数量会非常多。是否存在共识协议的替代版本，使得能够更容易地挖掘谜题，而不需要几乎即时地广播所有解，这仍然是一个公开的问题。</p>
<p class="h"><a id="sec8_5" class="calibre3"/> <b class="calibre11"> 8.5 级。股权证明和虚拟开采</b></p>
<p class="noindent">为了总结这一章，让我们看看用虚拟挖掘代替计算谜题的想法。这个术语指的是一组不同的方法，但是它们都有一个共同点，即它们只需要参与的挖掘者花费很少的计算资源。</p>
<p class="h1">关闭采矿回路</p>
<p class="noindent">作为一个思想实验，假设比特币或另一种加密货币成为全球支付的主导形式。矿工将首先持有一些加密货币，<a id="page_207" class="calibre3"/>用它来购买采矿设备和电力，消耗这些资源，并在此过程中以采矿奖励的形式获得新的加密货币(<a href="part0014.html#fig8_3" class="calibre3">图 8.3 </a>)。这个过程不断消耗能源和原材料。</p>
<div class="cap">
<p class="image"><a id="fig8_3" class="calibre1"/>T12】</p>
<p class="figcaptionc">图 8.3。比特币挖矿的周期。华硕 NVIDIA GeForce 210 静音显卡，带 HDMI，由 Joydeep 提供。工厂图片由 Dtbohrer 提供。</p>
</div>
<p class="indent">一旦采矿硬件成为一种商品，电力成为一种商品(通常已经成为商品)，就如何有效地将最初持有的加密货币转化为采矿奖励而言，没有任何一家矿商会比任何其他矿商拥有显著优势。除了效率上的微小差异，谁对采矿业投资最多，谁就能获得最多的回报。</p>
<p class="indent">激发虚拟采矿的基本问题是:如果我们去掉在电力和设备上花钱的步骤，会发生什么？毕竟这个过程主要是用来证明谁在挖矿上投入最多。为什么不简单地将采矿“权力”按实际持有货币多少的比例直接分配给所有货币持有者？</p>
<p class="indent">回想一下，比特币挖矿的最初目标是实现一种对区块链进行投票的形式，计算能力越强的矿工获得的选票越多。相反，我们可以设计投票系统，让投票由一个人目前持有多少货币来决定。</p>
<p class="h1">虚拟采矿的优势</p>
<p class="noindent">这种方法的主要优势是显而易见的:它从<a href="part0014.html#fig8_3" class="calibre3">图 8.3 </a>中移除了浪费的右半个采矿周期，留给我们一个封闭的系统，如图<a href="part0014.html#fig8_4" class="calibre3">图 8.4 </a>所示。</p>
<div class="cap">
<p class="image"><a id="fig8_4" class="calibre1"/> <img src="../images/00089.jpeg" alt="Image" class="calibre13"/></p>
<p class="figcaptionc">图 8.4。虚拟采矿循环。</p>
</div>
<p class="indent">除了简单之外，这种方法还能显著减少比特币的环境足迹。它不会将能量消耗降低到零，因为矿工将总是不得不花费一些计算资源来与网络通信和验证。一些虚拟挖掘方案也需要少量的计算挖掘。但不管是哪种情况，几乎所有用比特币进行的挖掘工作都有可能被淘汰。</p>
<p class="indent">虚拟采矿也可能减少集中化的趋势。因为不涉及采矿硬件，所以不存在对 ASIC 优势的担忧；任何矿工都能像其他人一样高效地采矿。任何虚拟采矿拼图都实现了抗 ASIC 拼图的所有目标。</p>
<p class="indent">也许最重要的是，虚拟采矿可能解决我们在抗 ASIC 难题的背景下讨论的问题，即矿工可能不会投资于货币的长期健康。任何持有比特币的人实际上都是该货币的利益相关者，而强大的虚拟矿工(比如持有所有货币 51%或更多的人)是非常大的利益相关者。这个矿工有动机去做对整个系统有益的事情，因为这样的行为增加了他持有的硬币的价值。这一论点甚至强于这样一种论点，即坐拥大量采矿设备(其价值取决于货币的未来)的矿工不会有恶意行为。</p>
<p class="indent">这种虚拟采矿的论点就是术语<i class="calibre9">利益证明</i>的来源。甚至比消除采矿和节约能源更重要的是，虚拟采矿最根本的动机可能是确保采矿由货币中的利益相关者完成，这些利益相关者最有动力成为系统的好管家。</p>
<p class="h1">实现虚拟挖掘:Peercoin</p>
<p class="noindent">存在许多虚拟采矿的变体，我们描述其中一些最常见的想法。由于比特币的流行，这些想法尚未经过科学和严格的研究，也没有经过工作证明那样的实际测试。</p>
<p class="indent">首先，考虑一下 Peercoin 采取的方法，该方法于 2012 年推出，是第一个使用股权证明的替代硬币。Peercoin 是一种混合的工作证明/赌注证明算法，其中赌注以“硬币年龄”命名。特定未用完交易输出的硬币年龄是该输出持有的数量和该输出保持未用完的块数的乘积。要开采 Peercoin 的一个区块，矿工必须解决基于阿沙 256 的计算难题，就像比特币一样。然而，这个难题的难度根据矿工们愿意消费多少硬币年龄而下调。为了做到这一点，该块包括一个特殊的“硬币赌注”交易，其中一些交易只是用来将它们的硬币年龄重置为零。coinstake 事务中消耗的硬币年龄的总和决定了工作证明难题使给定块有效的难度。</p>
<p class="indent">矿工可以用很少的木桩和大量的计算能力来采矿，但选择难度公式是为了在消耗一些硬币时更容易找到区块。计算难题的效果主要是确保如果两个矿工试图消耗相似数量的硬币年龄，这个过程是随机的。</p>
<p class="indent">许多虚拟采矿替代币采用了略有不同的设计，包括 Nxt、BitShares、BlackCoin 和 Reddcoin。在每一种货币中，一定数量的赌注被用来使计算难题变得更加容易，据称到了计算难题不再是采矿中的主要挑战的地步。</p>
<p class="h1">替代形式的股份</p>
<p class="noindent">这种混合模式的两种替代方案值得讨论:</p>
<p class="bullt"><i class="calibre9">股权证明</i>。最纯粹的股权证明形式只是让那些能证明自己控制大量货币的人更容易采矿。这种方法类似于 Peercoin 的硬币年龄证明，只是没有考虑年龄。这种方法的缺点是，与成功挖掘后重置的硬币时代不同，最富有的参与者总是被给予最容易的挖掘难题。</p>
<p class="bull"><i class="calibre9">存款证明</i>。在这个公式中，当一个矿工用硬币铸造一个砖块时，硬币会被冻结一定数量的砖块。这可以被认为是硬币时代的一面镜子:这一系统不是奖励矿工持有过去长时间未使用的硬币，而是奖励那些愿意在未来长时间保持硬币未使用的矿工。在这两种方法中，矿商的利益实际上来自于无法使用硬币进行其他行为的机会成本。</p>
<p class="h1">无关紧要的问题</p>
<p class="noindent">虚拟采矿是一个正在进行的研究的活跃领域，有重大的开放问题。尽管其他一些加密货币已经推出并通过虚拟采矿存活下来，但它们面临着与比特币一样的压力，要抵御动机明确的攻击者。</p>
<p class="indent">虚拟采矿方案的一般漏洞通常被称为<i class="calibre9">无关紧要的</i>问题或<i class="calibre9">利益研磨攻击</i>。假设一个拥有比例为α &lt; 0.5 的攻击者试图创建一个由<i class="calibre9"> k </i>个方块组成的分支。如<a href="part0008.html#7K4G0-ea268daff50b4c55a00d858ef79f4a6c" class="calibre3">第二章</a>所述，这种攻击会有很大概率失败(具体来说，成功的概率随着<i class="calibre9"> k </i>呈指数递减)。在传统采矿中，失败的攻击具有显著的机会成本，因为矿工在采矿过程中可以获得采矿奖励，而不是在失败的攻击上浪费采矿资源。</p>
<p class="indent">有了虚拟采矿，这种机会成本就不存在了。矿工可以使用他的木桩在当前最长的链条中采矿，同时尝试创建一个叉子。如果他的叉子成功了，那将会消耗掉他大量的赌注。如果它失败了，它失败的记录将不会反映在最终最长的链上。因此，理性的矿工可能会不断尝试分叉链。</p>
<div class="box">
<p class="quotebb"><a id="page_210" class="calibre3"/> <b class="calibre11">分叉攻击和检查点</b></p>
<p class="quoteb">当你下载比特币核心时，它带有一些硬编码的检查点，或者过去块的散列。这主要是为了使区块链的初始下载更流畅。如果没有检查点，其他节点可能会向您发送虚假但有效的块和分支。今天，攻击者很容易在较低的积木高度，即接近创世纪积木的高度，生成具有有效谜题解的积木，因为开始时的难度相对较小。您最终会发现这些块不在最长的有效分支上(更准确地说，是总难度最高的有效分支)，但是这样做将会浪费资源。</p>
<p class="quoteb">一些替代硬币，尤其是虚拟采矿方案，已经采用了一种强大的检查点形式来抵御分叉攻击。节点从指定的检查点节点接收由指定的私钥签名的定期检查点更新。节点将丢弃与检查点冲突的分支。这允许检查点操作员，通常是 altcoin 创建者，在出现分叉的情况下选择获胜者，甚至“回滚”方块。这个设计很有趣，但它不再是一个分散的共识协议。</p>
</div>
<p class="indent">对于以太币(2015 年年中推出的替代硬币，在第 10 章中讨论过)，一项名为“Slasher”的提案允许惩罚试图分叉链条的矿工。在 Slasher 中，使用 stake 来采矿需要用对应于构成矿工股份的事务的私钥来签署当前块。如果一个矿工曾经使用相同的股份签署两个不一致的链(其中没有一个是另一个的前缀)，Slasher 允许其他矿工稍后在区块链中输入这两个签名作为不当行为的证据，并收集该股份的一部分作为奖金。虽然这种提出的机制似乎提供了一种有效的解决方案，但是协议的细节相当复杂，并且它还没有被成功地部署。</p>
<p class="indent">最后，正如我们在传统采矿计划中看到的那样，矿工可能根本没有强烈的动机去攻击，因为这将破坏系统并损害他们的利益，即使攻击是成功的。</p>
<p class="h1">虚拟采矿的其他缺点</p>
<p class="noindent">另外两个缺点值得一提。第一，某些形式的虚拟采矿，即使没有磨桩，也可能使某些类型的攻击变得更容易，因为有可能为采矿力量的爆发“储蓄”。例如，大量的硬币-股份可以汇集起来，使一个戏剧性的采矿激增，也许，引入一个分叉。即使像 Slasher 这样的系统被用来阻止同时在两个链上采矿，这也是可能的。为了阻止这种类型的攻击，Peercoin 在计算硬币年龄时将年龄参数限制为 90 天。</p>
<p class="indent">第二个问题是，如果一个虚拟采矿系统中的矿工获得了 51%的可用股份，她可以通过只在自己的区块上采矿来永远保持这一股份，实际上控制了区块链。即使新的股份来自采矿奖励和交易费，51%的矿工将获得新的股份，她在总股份中的份额将慢慢接近 100%。在传统采矿中，即使 51%的矿工存在，也总是有可能出现一些新的矿工，他们拥有更多的采矿设备和能源，并将减少大多数矿工。在虚拟采矿中要避免这个问题要困难得多。</p>
<p class="h1">虚拟挖矿实际上能行得通吗？</p>
<p class="noindent">虚拟采矿在主流比特币社区中仍有一些争议。有一种观点认为，安全性从根本上来说需要消耗真正的资源，需要真正的计算硬件，并消耗真正的电力来找到难题的解决方案。如果这种说法是可信的，那么工作证明系统产生的明显浪费可以解释为该系统提供的安全性的成本。但是这个论点还没有被证实，就像虚拟采矿的安全性还没有被证实一样。</p>
<p class="indent">总之，改变比特币采矿之谜的许多方面可能是可取的，这一直是一个激烈研究和创新的领域。然而，到目前为止，似乎没有一种替代方案既证明了理论上的合理性，又找到了实际应用。例如，即使 scrypt 在 altcoins 中一直是一个受欢迎的选择，但它实际上并没有实现 ASIC 抗性，其有用性也不清楚。完全有可能的是，替代性的采矿难题在未来会获得更大的成功。毕竟，比特币本身是在几十年创造加密货币的失败尝试之后出现的，它成功地在原则性设计和实际权衡之间找到了最佳平衡点。</p>
<p class="h"><b class="calibre11">延伸阅读</b></p>
<p class="refn">定义记忆硬函数并提出 scrypt 的论文是:</p>
<pre>Percival, Colin. “Stronger Key Derivation via Sequential Memory-Hard Functions,” 2009. Available at <a href="https://www.bsdcan.org/2009/schedule/attachments/87_scrypt.pdf" class="calibre3">https://www.bsdcan.org/2009/schedule/attachments/87_scrypt.pdf</a>.</pre>
<p class="refn">关于受内存限制的函数的早期论文包括:</p>
<pre>Abadi, Martin, Mike Burrows, Mark Manasse, and Ted Wobber. “Moderately Hard, Memory-Bound Functions.” <i class="calibre9">ACM Transactions on Internet Technology</i> 5(2), 2005.</pre>
<pre>Dwork, Cynthia, Andrew Goldberg, and Moni Naor. “On Memory-Bound Functions for Fighting Spam.” In <i class="calibre9">Advances in Cryptology—Crypto 2003</i>. Berlin: Springer, 2003.</pre>
<p class="refn">布谷鸟周期的建议可以在:</p>
<pre>Tromp, John. “Cuckoo Cycle: A Memory-Hard Proof-of-Work System.” IACR Cryptology ePrint Archive, 2014. Available at <a href="https://eprint.iacr.org/2014/059.pdf" class="calibre3">https://eprint.iacr.org/2014/059.pdf</a>.</pre>
<p class="refn">永久硬币的提案在:</p>
<pre>Miller, Andrew, Ari Juels, Elaine Shi, Bryan Parno, and Justin Katz. “Permacoin: Repurposing Bitcoin Work for Data Preservation.” In <i class="calibre9">Proceedings of the 2014 IEEE Symposium on Security and Privacy</i>, 2014. Available at <a href="http://research.microsoft.com/pubs/217984/permacoin.pdf" class="calibre3">http://research.microsoft.com/pubs/217984/permacoin.pdf</a>.</pre>
<p class="refn"><a id="page_212" class="calibre3"/>本文讨论了不同的哈希函数设计和 SHA-3 竞赛:</p>
<pre>Preneel, Bart. “The First 30 Years of Cryptographic Hash Functions and the NIST SHA-3 Competition.” In <i class="calibre9">Topics in Cryptology—CT-RSA, 2010</i>. Berlin: Springer, 2010.</pre>
<p class="refn">对不可外包谜题的建议是:</p>
<pre>Miller, Andrew, Elaine Shi, Ahmed Kosba, and Jonathan Katz. “Nonoutsourceable Scratch-Off Puzzles to Discourage Bitcoin Mining Coalitions.” In <i class="calibre9">Proceedings of the 22nd ACM Conference on Computer and Communications Security</i>, forthcoming.</pre>
</body></html>
</body></html>